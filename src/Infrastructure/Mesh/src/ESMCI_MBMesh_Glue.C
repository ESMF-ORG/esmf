// $Id$
//
// Earth System Modeling Framework
// Copyright 2002-2020, University Corporation for Atmospheric Research,
// Massachusetts Institute of Technology, Geophysical Fluid Dynamics
// Laboratory, University of Michigan, National Centers for Environmental
// Prediction, Los Alamos National Laboratory, Argonne National Laboratory,
// NASA Goddard Space Flight Center.
// Licensed under the University of Illinois-NCSA License.
//
//==============================================================================

//==============================================================================
//
// This file contains the Fortran interface code to link F90 and C++.
//
//------------------------------------------------------------------------------
// INCLUDES
//------------------------------------------------------------------------------

// Take out if MOAB isn't being used
#if defined ESMF_MOAB

#include <string>
#include <ostream>
#include <iterator>
#include <vector>

#include "ESMCI_Macros.h"
#include "ESMCI_F90Interface.h"
#include "ESMCI_LogErr.h"
#include "ESMCI_VM.h"
#include "ESMCI_CoordSys.h"

#include "ESMCI_TraceMacros.h"  // for profiling

#include "Mesh/include/ESMCI_MathUtil.h"
#include "Mesh/include/Regridding/ESMCI_MeshRegrid.h"

#include "Mesh/include/ESMCI_MBMesh.h"
#include "Mesh/include/ESMCI_MBMesh_Glue.h"
#include "Mesh/include/ESMCI_MBMesh_Redist.h"
#include "Mesh/include/ESMCI_MBMesh_Util.h"


#include "MBTagConventions.hpp"
#include "moab/ParallelComm.hpp"

//-----------------------------------------------------------------------------
 // leave the following line as-is; it will insert the cvs ident string
 // into the object file for tracking purposes.
 static const char *const version = "$Id$";
//-----------------------------------------------------------------------------


using namespace ESMCI;

// #define DEBUG_MASK
// #define DEBUG_OUTPUT
// #define DEBUG_NODE_COORDS
// #define DEBUG_ELEM_COORDS
// #define DEBUG_OWNED


extern "C" void FTN_X(f_esmf_getmeshdistgrid)(int*, int*, int*, int*);

void MBMesh_create(void **mbmpp,
                      int *pdim, int *sdim,
                      ESMC_CoordSys_Flag *coordSys, int *rc)
{
#undef  ESMC_METHOD
#define ESMC_METHOD "MBMesh_create()"

  // Init output
  *mbmpp=NULL;


  // Initialize the parallel environment for mesh (if not already done)
#if 0
     {
       int localrc;
       int rc;
       ESMCI::Par::Init("MESHLOG", false /* use log */,VM::getCurrent(&localrc)->getMpi_c());
       if (ESMC_LogDefault.MsgFoundError(localrc,ESMCI_ERR_PASSTHRU,ESMC_CONTEXT,NULL))
          throw localrc;  // bail out with exception
      }
#endif


      // Some error checking of input
     if (*pdim > *sdim) {
       if(ESMC_LogDefault.MsgFoundError(ESMC_RC_ARG_VALUE,
         "- Parametric dimension can't be greater than spatial dimension",
                                        ESMC_CONTEXT, rc)) return;
     }

     if ((*pdim < 2) || (*pdim >3)) {
       if(ESMC_LogDefault.MsgFoundError(ESMC_RC_ARG_VALUE,
         "- Parametric dimension can't be greater than 3D or less than 2D",
                                        ESMC_CONTEXT, rc)) return;
     }

    if ((*sdim < 2) || (*sdim >3)) {
      if(ESMC_LogDefault.MsgFoundError(ESMC_RC_ARG_VALUE,
        "- Spatial dimension can't be greater than 3D or less than 2D",
                                       ESMC_CONTEXT, rc)) return;
    }


    // Moab error
    int merr;

    // New Mesh
    MBMesh *mbmp = new MBMesh();

    // Get cartesian dimension
    int cart_sdim;
    int localrc;
    localrc=ESMCI_CoordSys_CalcCartDim(*coordSys, *sdim, &cart_sdim);
    if (ESMC_LogDefault.MsgFoundError(localrc,ESMCI_ERR_PASSTHRU,ESMC_CONTEXT,rc))
      return;

    // Create MOAB Mesh
    Interface *moab_mesh=new Core();

    // Default value
    int int_def_val = 0;
    double dbl_def_val[3] = {0.0, 0.0, 0.0};

     // Setup global id tag
    int_def_val=0;
    merr=moab_mesh->tag_get_handle(GLOBAL_ID_TAG_NAME, 1, MB_TYPE_INTEGER, mbmp->gid_tag, MB_TAG_DENSE, &int_def_val);
    if (merr != MB_SUCCESS) {
      if(ESMC_LogDefault.MsgFoundError(ESMC_RC_MOAB_ERROR,
                                       moab::ErrorCodeStr[merr], ESMC_CONTEXT, rc)) return;
    }

    // Setup orig_pos tag
    int_def_val=-1;
    merr=moab_mesh->tag_get_handle("orig_pos", 1, MB_TYPE_INTEGER, mbmp->orig_pos_tag, MB_TAG_EXCL|MB_TAG_DENSE, &int_def_val);
    if (merr != MB_SUCCESS) {
      if(ESMC_LogDefault.MsgFoundError(ESMC_RC_MOAB_ERROR,
                                       moab::ErrorCodeStr[merr], ESMC_CONTEXT, rc)) return;
    }

    // Setup owner tag
    int_def_val=-1;
    merr=moab_mesh->tag_get_handle("owner", 1, MB_TYPE_INTEGER, mbmp->owner_tag, MB_TAG_EXCL|MB_TAG_DENSE, &int_def_val);
    if (merr != MB_SUCCESS) {
      if(ESMC_LogDefault.MsgFoundError(ESMC_RC_MOAB_ERROR,
                                       moab::ErrorCodeStr[merr], ESMC_CONTEXT, rc)) return;
    }

    // Setup node_orig_coord tag
    mbmp->has_node_orig_coords=false;
    if (*coordSys != ESMC_COORDSYS_CART) {
      dbl_def_val[0]=dbl_def_val[1]=dbl_def_val[2]=-1.0;
      merr=moab_mesh->tag_get_handle("node_orig_coords", *sdim, MB_TYPE_DOUBLE, mbmp->node_orig_coords_tag, MB_TAG_EXCL|MB_TAG_DENSE, dbl_def_val);
      if (merr != MB_SUCCESS) {
        if(ESMC_LogDefault.MsgFoundError(ESMC_RC_MOAB_ERROR,
                                         moab::ErrorCodeStr[merr], ESMC_CONTEXT, rc)) return;
      }
      mbmp->has_node_orig_coords=true;
    }

    // Set Moab Mesh
    mbmp->mesh=moab_mesh;

    // Set dimensions
    mbmp->pdim=*pdim;
    mbmp->sdim=cart_sdim;
    mbmp->orig_sdim=*sdim;
    mbmp->coordsys=*coordSys;

    // Output mesh
    *mbmpp=(void *)mbmp;

    // Set return code
    if (rc!=NULL) *rc = ESMF_SUCCESS;

} // meshcreate


void MBMesh_addnodes(void **mbmpp, int *num_nodes, int *nodeId,
                     double *nodeCoord, int *nodeOwner, InterArray<int> *nodeMaskII,
                     ESMC_CoordSys_Flag *_coordSys, int *_orig_sdim,
                       int *rc)
{
#undef  ESMC_METHOD
#define ESMC_METHOD "MBMesh_addnodes()"

  // Should we do exception handling in here, since MOAB doesn't???
   try {

     // Get Moab Mesh wrapper
      MBMesh *mbmp=reinterpret_cast<MBMesh*> (*mbmpp);

     //Get MOAB Mesh
     Interface *moab_mesh=mbmp->mesh;

     // Get some handy variables
     ESMC_CoordSys_Flag coordSys=*_coordSys;
     int sdim = mbmp->sdim; // spatial dim of mesh (after conversion to Cartesian)
     int orig_sdim = *_orig_sdim;   // original sdim (before conversion to Cartesian)

     // Moab error
     int merr;

#if 0
     // Initialize the parallel environment for mesh (if not already done)
     {
       int localrc;
       int rc;
       ESMCI::Par::Init("MESHLOG", false /* use log */,VM::getCurrent(&localrc)->getMpi_c());
       if (ESMC_LogDefault.MsgFoundError(localrc,ESMCI_ERR_PASSTHRU,ESMC_CONTEXT,NULL))
         throw localrc;  // bail out with exception
     }
#endif

     // Get petCount for error checking
     int localrc;
     int petCount = VM::getCurrent(&localrc)->getPetCount();
    if (ESMC_LogDefault.MsgFoundError(localrc,ESMCI_ERR_PASSTHRU,ESMC_CONTEXT,NULL))
      throw localrc;  // bail out with exception

    // Check node owners
    for (int n = 0; n < *num_nodes; ++n) {
      if ((nodeOwner[n]<0) || (nodeOwner[n]>petCount-1)) {
         if(ESMC_LogDefault.MsgFoundError(ESMC_RC_ARG_VALUE,
           "- Bad nodeOwner value ", ESMC_CONTEXT,&localrc)) throw localrc;
      }
     }

    // Number of verts
    int num_verts=*num_nodes;
    mbmp->num_verts=num_verts;

    // Allocate temp storage for verts
    EntityHandle *verts=new EntityHandle[num_verts];
    mbmp->verts=verts; // Put temporarily in structure for use in element creation

     // Create new nodes
    for (int n = 0; n < num_verts; ++n) {
      double cart_coords[3];

      // Init to 0.0 incase less than 3D
      cart_coords[0]=0.0; cart_coords[1]=0.0; cart_coords[2]=0.0;

      // Convert to cartesian
      ESMCI_CoordSys_ConvertToCart(coordSys, orig_sdim,
                                   nodeCoord+orig_sdim*n, cart_coords);
#ifdef DEBUG_NODE_COORDS
      printf("%d# node %d [%f, %f] - [%f,%f,%f]\n", localPet, nodeId[n], nodeCoord[orig_sdim*n+0], nodeCoord[orig_sdim*n+1], cart_coords[0],cart_coords[1],cart_coords[2]);
#endif
      // Add vertex
      merr=moab_mesh->create_vertex(cart_coords,verts[n]);
      if (merr != MB_SUCCESS) {
        if(ESMC_LogDefault.MsgFoundError(ESMC_RC_MOAB_ERROR,
          moab::ErrorCodeStr[merr], ESMC_CONTEXT,&localrc)) throw localrc;
      }
    }

    // Set Ids
    merr=moab_mesh->tag_set_data(mbmp->gid_tag, verts, num_verts, nodeId);
    if (merr != MB_SUCCESS) {
      if(ESMC_LogDefault.MsgFoundError(ESMC_RC_MOAB_ERROR,
         moab::ErrorCodeStr[merr], ESMC_CONTEXT,&localrc)) throw localrc;
    }

    // Set Owners
    merr=moab_mesh->tag_set_data(mbmp->owner_tag, verts, num_verts, nodeOwner);
    if (merr != MB_SUCCESS) {
      if(ESMC_LogDefault.MsgFoundError(ESMC_RC_MOAB_ERROR,
         moab::ErrorCodeStr[merr], ESMC_CONTEXT,&localrc)) throw localrc;
    }


    // Set orig_pos
    for (int n = 0; n < num_verts; ++n) {
      merr=moab_mesh->tag_set_data(mbmp->orig_pos_tag, verts+n, 1, &n);
      if (merr != MB_SUCCESS) {
        if(ESMC_LogDefault.MsgFoundError(ESMC_RC_MOAB_ERROR,
                    moab::ErrorCodeStr[merr], ESMC_CONTEXT,&localrc)) throw localrc;
      }
    }

    // Set original coords
    if (mbmp->has_node_orig_coords) {
      // Set orinal coords
      merr=moab_mesh->tag_set_data(mbmp->node_orig_coords_tag, verts, num_verts, nodeCoord);
      if (merr != MB_SUCCESS) {
        if(ESMC_LogDefault.MsgFoundError(ESMC_RC_MOAB_ERROR,
                       moab::ErrorCodeStr[merr], ESMC_CONTEXT,&localrc)) throw localrc;
      }
    }

    // Set mask information
    mbmp->has_node_mask=false;
    if (present(nodeMaskII)) { // if masks exist
      // Error checking
      if ((nodeMaskII)->dimCount !=1) {
        int localrc;
         if(ESMC_LogDefault.MsgFoundError(ESMC_RC_ARG_RANK,
                                         "- nodeMask array must be 1D ", ESMC_CONTEXT,  &localrc)) throw localrc;
      }

      if ((nodeMaskII)->extent[0] != *num_nodes) {
        int localrc;
        if(ESMC_LogDefault.MsgFoundError(ESMC_RC_ARG_RANK,
                                         "- nodeMask array must be the same size as the nodeIds array ", ESMC_CONTEXT, &localrc)) throw localrc;
      }

      // Setup node mask tag
      int int_def_val=0; // So things are by default not masked
      merr=moab_mesh->tag_get_handle("node_mask", 1, MB_TYPE_INTEGER, mbmp->node_mask_tag, MB_TAG_EXCL|MB_TAG_DENSE, &int_def_val);
      if (merr != MB_SUCCESS) {
        if(ESMC_LogDefault.MsgFoundError(ESMC_RC_MOAB_ERROR,
                                         moab::ErrorCodeStr[merr], ESMC_CONTEXT, rc)) return;
      }

      // Setup node mask value tag
      int_def_val=0; // So things are by default not masked
      merr=moab_mesh->tag_get_handle("node_mask_val", 1, MB_TYPE_INTEGER, mbmp->node_mask_val_tag, MB_TAG_EXCL|MB_TAG_DENSE, &int_def_val);
      if (merr != MB_SUCCESS) {
        if(ESMC_LogDefault.MsgFoundError(ESMC_RC_MOAB_ERROR,
                                         moab::ErrorCodeStr[merr], ESMC_CONTEXT, rc)) return;
      }
      // Set values in node mask value
      merr=moab_mesh->tag_set_data(mbmp->node_mask_val_tag, verts, num_verts, nodeMaskII->array);
      if (merr != MB_SUCCESS) {
        if(ESMC_LogDefault.MsgFoundError(ESMC_RC_MOAB_ERROR,
                                         moab::ErrorCodeStr[merr], ESMC_CONTEXT,&localrc)) throw localrc;
      }

      // Record the fact that it has masks
      mbmp->has_node_mask=true;

#ifdef DEBUG_MASK
      {
        int localrc = 0;
        int merr = 0;

        int node_mask[num_verts];
        if (mbmp->has_node_mask) { 
          Range nodes;
          merr=mbmp->mesh->get_entities_by_dimension(0, 0, nodes);
          if (merr != MB_SUCCESS) throw (ESMC_RC_MOAB_ERROR);
          merr=mbmp->mesh->tag_get_data(mbmp->node_mask_val_tag, nodes, &node_mask);
          if (merr != MB_SUCCESS)
            if(ESMC_LogDefault.MsgFoundError(ESMC_RC_MOAB_ERROR,
              moab::ErrorCodeStr[merr], ESMC_CONTEXT,&localrc)) throw localrc;
        }

        printf("%d# has_node_mask = %s [", Par::Rank(), mbmp->has_node_mask ? "true" : "false");
        for (int i = 0; i < num_verts; ++i)
          printf("%d, ", node_mask[i]);
        printf("]\n");
      }
#endif

    }

#ifdef DEBUG_NODE_COORDS
  {
    
    
    Range nodes;
    merr=mbmp->mesh->get_entities_by_dimension(0, 0, nodes);
    MBMESH_CHECK_ERR(merr, localrc);
    
    for(Range::const_iterator it=nodes.begin(); it !=nodes.end(); it++) {
      const EntityHandle *node=&(*it);
    
      int nid;
      merr=mbmp->mesh->tag_get_data(mbmp->gid_tag, node, 1, &nid);
      MBMESH_CHECK_ERR(merr, localrc);
      printf("MBMesh_addnodes node %d, [",nid);
    
      double c[3];
      merr = mbmp->mesh->get_coords(node, 1, c);
      MBMESH_CHECK_ERR(merr, localrc);
    
      for (int i=0; i<mbmp->sdim; ++i)
        printf("%f, ", c[i]);
      printf("]\n");
    }
  }
#endif

  } catch(std::exception &x) {
    // catch Mesh exception return code
    if (x.what()) {
      ESMC_LogDefault.MsgFoundError(ESMC_RC_INTNRL_BAD,
                                          x.what(), ESMC_CONTEXT, rc);
    } else {
      ESMC_LogDefault.MsgFoundError(ESMC_RC_INTNRL_BAD,
                                          "UNKNOWN", ESMC_CONTEXT, rc);
    }

     return;
  }catch(int localrc){
    // catch standard ESMF return code
    ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU, ESMC_CONTEXT, rc);
    return;
  } catch(...){
    ESMC_LogDefault.MsgFoundError(ESMC_RC_INTNRL_BAD,
       "- Caught unknown exception", ESMC_CONTEXT, rc);
    return;
  }

  // Set return code
   if (rc!=NULL) *rc = ESMF_SUCCESS;

}


//Get the entity type from parametric dimension and ESMF etype
EntityType get_entity_type(int pdim, int etype) {
  if (pdim==2) {
    if (etype==3) return MBTRI;
    else if (etype==4) return MBQUAD;
    else {
      int localrc;
      if(ESMC_LogDefault.MsgFoundError(ESMC_RC_ARG_VALUE,
                                       "- unrecognized ESMF element type",
                                       ESMC_CONTEXT, &localrc)) throw localrc;
    }
  } else if (pdim==3) {
    if (etype==10) return MBTET;
    else if (etype==12) return MBHEX;
    else {
      int localrc;
      if(ESMC_LogDefault.MsgFoundError(ESMC_RC_ARG_VALUE,
                                       "- unrecognized ESMF element type",
                                       ESMC_CONTEXT, &localrc)) throw localrc;
    }
  }
}


// TODO: Put this someplace to share with other GLUE code
// Get the number of nodes from the element type
 // Get the element topology
int ElemType2NumNodes(int pdim, int sdim, int etype) {
  if (pdim==2) {
    return etype;
  } else if (pdim==3) {
    if (etype==10) return 4;
    else if (etype==12) return 8;
    else {
       int localrc;
      if(ESMC_LogDefault.MsgFoundError(ESMC_RC_ARG_VALUE,
       "- for a mesh with parametric dimension 3 element types must be either tetrahedrons or hexahedrons",
                                        ESMC_CONTEXT, &localrc)) throw localrc;
     }
   }
}

// TODO: Put this someplace to share with other GLUE code
// triangulate > 4 sided
// sdim = spatial dim
// num_p = number of points in poly
  // p     = poly coords size=num_p*sdim
// td    = temporary buffer size=num_p*sdim
// ti    = temporary integer buffer size = num_p
// tri_ind = output array  size = 3*(nump-2)
// tri_frac = fraction each triangle is of whole poly size=(num_p-2)
static void triangulate(int sdim, int num_p, double *p, double *td, int *ti, int *tri_ind,
                 double *tri_frac) {
          int localrc;
#undef  ESMC_METHOD
#define ESMC_METHOD "triangulate()"

          // Call into triagulation routines
          int ret;
          if (sdim==2) {
            ret=triangulate_poly<GEOM_CART2D>(num_p, p, td,
                                              ti, tri_ind);
          } else if (sdim==3) {
            ret=triangulate_poly<GEOM_SPH2D3D>(num_p, p, td,
                                               ti, tri_ind);
          } else {
             if (ESMC_LogDefault.MsgFoundError(ESMC_RC_ARG_INCOMP,
                                          " - triangulate can't be used for polygons with spatial dimension not equal to 2 or 3",
                                              ESMC_CONTEXT, &localrc)) throw localrc;
          }

          // Check return code
          if (ret != ESMCI_TP_SUCCESS) {
            if (ret == ESMCI_TP_DEGENERATE_POLY) {
              if (ESMC_LogDefault.MsgFoundError(ESMC_RC_ARG_INCOMP,
                   " - can't triangulate a polygon with less than 3 sides",
                                                ESMC_CONTEXT, &localrc)) throw localrc;
            } else if (ret == ESMCI_TP_CLOCKWISE_POLY) {
              if (ESMC_LogDefault.MsgFoundError(ESMC_RC_ARG_INCOMP,
                   " - clockwise polygons not supported in triangulation routine",
                                                ESMC_CONTEXT, &localrc)) throw localrc;
            } else {
                if (ESMC_LogDefault.MsgFoundError(ESMC_RC_INTNRL_BAD,
                                                " - unknown error in triangulation", ESMC_CONTEXT, &localrc)) throw localrc;
             }
          }


          // Calculate triangule areas
          double tot_area=0.0;
          int ti_pos=0;
          for (int i=0; i<num_p-2; i++) {
            // Copy triangle coordinates into td
            int td_pos=0;
            for (int j=0; j<3; j++) {
              double *pnt=p+sdim*tri_ind[ti_pos+j];
              for (int k=0; k<sdim; k++) {
                td[td_pos]=pnt[k];
                td_pos++;
              }
            }

             // compute area of triangle
             double tri_area;
            if (sdim == 2) {
              tri_area = area_of_flat_2D_polygon(3, td);
            } else if (sdim == 3) {
              tri_area = great_circle_area(3, td);
            } // Other sdim caught above

            // Save areas to use for computing fractions
            tri_frac[i]=tri_area;

            // compute total
            tot_area += tri_area;

            // Advance to next triangle
            ti_pos +=3;
          }

          // Calculate triangle fractions
           for (int i=0; i<num_p-2; i++) {
            if (tot_area >0.0) tri_frac[i]=tri_frac[i]/tot_area;
            else tri_frac[i]=0.0;
          }

    return;
}

// triangulate > 4 sided
// sdim = spatial dim
// num_p = number of points in poly
// p     = poly coords size=num_p*sdim
// oeid  = id of original element for debug output
// td    = temporary buffer size=num_p*sdim
// ti    = temporary integer buffer size = num_p
// tri_ind = output array  size = 3*(nump-2)
// tri_area = area of each sub-triangle is of whole poly size=(num_p-2)
static void triangulate_warea(int sdim, int num_p, double *p, int oeid,
                              double *td, int *ti, int *tri_ind,
                              double *tri_area) {
#undef  ESMC_METHOD
#define ESMC_METHOD "triangulate_warea()"

          int localrc;

          // Call into triagulation routines
          int ret;
          if (sdim==2) {
            ret=triangulate_poly<GEOM_CART2D>(num_p, p, td,
                                              ti, tri_ind);
          } else if (sdim==3) {
            ret=triangulate_poly<GEOM_SPH2D3D>(num_p, p, td,
                                               ti, tri_ind);
          } else {
            if (ESMC_LogDefault.MsgFoundError(ESMC_RC_ARG_INCOMP,
                                          " - triangulate can't be used for polygons with spatial dimension not equal to 2 or 3",
                                              ESMC_CONTEXT, &localrc)) throw localrc;
          }

          // Check return code
          if (ret != ESMCI_TP_SUCCESS) {
            if (ret == ESMCI_TP_DEGENERATE_POLY) {
              if (ESMC_LogDefault.MsgFoundError(ESMC_RC_ARG_INCOMP,
                   " - can't triangulate a polygon with less than 3 sides",
                                                ESMC_CONTEXT, &localrc)) throw localrc;
            } else if (ret == ESMCI_TP_CLOCKWISE_POLY) {
              char msg[1024];
              sprintf(msg," - there was a problem (e.g. repeated points, clockwise poly, etc.) with the triangulation of the element with id=%d ",oeid);
              if (ESMC_LogDefault.MsgFoundError(ESMC_RC_ARG_INCOMP, msg,
                                              ESMC_CONTEXT, &localrc)) throw localrc;
            } else {
              if (ESMC_LogDefault.MsgFoundError(ESMC_RC_INTNRL_BAD,
                                                " - unknown error in triangulation", ESMC_CONTEXT, &localrc)) throw localrc;
            }
          }


          // Calculate triangule areas
          int ti_pos=0;
          for (int i=0; i<num_p-2; i++) {
            // Copy triangle coordinates into td
            int td_pos=0;
            for (int j=0; j<3; j++) {
              double *pnt=p+sdim*tri_ind[ti_pos+j];
              for (int k=0; k<sdim; k++) {
                td[td_pos]=pnt[k];
                td_pos++;
              }
            }

            // compute area of triangle
            double area;
            if (sdim == 2) {
              area = area_of_flat_2D_polygon(3, td);
            } else if (sdim == 3) {
              area = great_circle_area(3, td);
            } // Other sdim caught above

            // Save areas to use for computing fractions
            tri_area[i]=area;

            // Advance to next triangle
            ti_pos +=3;
          }

    return;
}


void MBMesh_addelements(void **mbmpp,
                        int *_num_elems, int *elemId, 
                        int *elemType, InterArray<int> *_elemMaskII ,
                        int *_areaPresent, double *elemArea,
                        int *_coordsPresent, double *elemCoords,
                        int *_num_elemConn, int *elemConn, int *regridConserve,
                        ESMC_CoordSys_Flag *_coordSys, int *_orig_sdim,
                        int *rc)
{
#undef  ESMC_METHOD
#define ESMC_METHOD "MBMesh_addelements()"

   try {

#if 0

  // Initialize the parallel environment for mesh (if not already done)
    {
 int localrc;
 int rc;
  ESMCI::Par::Init("MESHLOG", false /* use log */,VM::getCurrent(&localrc)->getMpi_c());
 if (ESMC_LogDefault.MsgFoundError(localrc,ESMCI_ERR_PASSTHRU,ESMC_CONTEXT,NULL))
   throw localrc;  // bail out with exception
    }
#endif

    // local rc code
    int localrc;

    ESMCI_MESHCREATE_TRACE_ENTER("MBMesh addelems setup")

    // Do this for now instead of initing mesh parallel stuff
    // TODO: MAYBE EVENTUALLY PUT THIS INTO MBMesh???
    MPI_Comm mpi_comm;
    {
    int localrc;
    int rc;
      mpi_comm=VM::getCurrent(&localrc)->getMpi_c();
      if (ESMC_LogDefault.MsgFoundError(localrc,ESMCI_ERR_PASSTHRU,ESMC_CONTEXT,NULL))
        throw localrc;  // bail out with exception
    }


    // Get localPet
    int localPet = VM::getCurrent(&localrc)->getLocalPet();
    if (ESMC_LogDefault.MsgFoundError(localrc,ESMCI_ERR_PASSTHRU,ESMC_CONTEXT,NULL))
      throw localrc;  // bail out with exception

    // MOAB error return
    int merr;

    // Get Moab Mesh wrapper
    MBMesh *mbmp=reinterpret_cast<MBMesh*> (*mbmpp);

    //Get MOAB Mesh
    Interface *moab_mesh=mbmp->mesh;

    int num_elems=*_num_elems;

    int num_elemConn=*_num_elemConn;

    InterArray<int> *elemMaskII=_elemMaskII;

    int areaPresent=*_areaPresent;

    int elemCoordsPresent=*_coordsPresent;

    ESMC_CoordSys_Flag coordSys=*_coordSys;
    int orig_sdim = *_orig_sdim;   // original sdim (before conversion to Cartesian)

    // Get parametric dimension
    int parametric_dim=mbmp->pdim;

    // Error check input
    //// Check element type
     if (parametric_dim==2) {
      // DONT DO THE CHECK BECAUSE WE NOW SUPPORT
      // ANY NUMBER OF CORNERS WITH PDIM=2
#if 0
      for (int i=0; i< num_elems; i++) {
        if ((elemType[i] != 5) && (elemType[i] != 9)) {
          int localrc;
          if(ESMC_LogDefault.MsgFoundError(ESMC_RC_ARG_VALUE,
            "- for a mesh with parametric dimension 2 element types must be either triangles or quadrilaterals ",
                                           ESMC_CONTEXT, &localrc)) throw localrc;
          }
      }
#endif
    } else if (parametric_dim==3) {
      for (int i=0; i< num_elems; i++) {
        if ((elemType[i] != 10) && (elemType[i] != 12)) {
          int localrc;
          if(ESMC_LogDefault.MsgFoundError(ESMC_RC_ARG_VALUE,
             "- for a mesh with parametric dimension 3 element types must be either tetrahedron or hexahedron ",
                                           ESMC_CONTEXT, &localrc)) throw localrc;
         }
      }
    }

    //// Check size of connectivity list
    int expected_conn_size=0;
    if (parametric_dim==2) {
      for (int i=0; i< num_elems; i++) {
        expected_conn_size += elemType[i];
      }
    } else if (parametric_dim==3) {
      for (int i=0; i< num_elems; i++) {
        if (elemType[i]==10) expected_conn_size += 4;
        else if (elemType[i]==12) expected_conn_size += 8;
      }
    }

    if (expected_conn_size != num_elemConn) {
      int localrc;
      if(ESMC_LogDefault.MsgFoundError(ESMC_RC_ARG_VALUE,
        "- element connectivity list doesn't contain the right number of entries ",
                                       ESMC_CONTEXT, &localrc)) throw localrc;
    }

    // Register element tags
    int     int_def_val=-1.0;
    double  dbl_def_val[3]= {0.0, 0.0, 0.0};
    double  dbl_def_val_one= 0.0;

    //// Register the frac field
    mbmp->has_elem_frac=false;
    if (*regridConserve == ESMC_REGRID_CONSERVE_ON) {

      merr=moab_mesh->tag_get_handle("elem_frac", 1, MB_TYPE_DOUBLE, mbmp->elem_frac_tag, MB_TAG_EXCL|MB_TAG_DENSE, &dbl_def_val_one);
      if (merr != MB_SUCCESS) {
        if(ESMC_LogDefault.MsgFoundError(ESMC_RC_MOAB_ERROR,
                                         moab::ErrorCodeStr[merr], ESMC_CONTEXT, rc)) return;
      }

      mbmp->has_elem_frac=true;
    }

    // Handle element masking
    mbmp->has_elem_mask=false;
     if (present(elemMaskII)) { // if masks exist
      // Error checking
      if (elemMaskII->dimCount !=1) {
        int localrc;
        if(ESMC_LogDefault.MsgFoundError(ESMC_RC_ARG_RANK,
          "- elementMask array must be 1D ", ESMC_CONTEXT,  &localrc)) throw localrc;
      }

      if (elemMaskII->extent[0] != num_elems) {
        int localrc;
        if(ESMC_LogDefault.MsgFoundError(ESMC_RC_ARG_RANK,
        "- elementMask array must be the same size as elementIds array ", ESMC_CONTEXT, &localrc)) throw localrc;
      }

      // Setup elem mask tag
      int_def_val=0; // So things are by default not masked
      merr=moab_mesh->tag_get_handle("elem_mask", 1, MB_TYPE_INTEGER, mbmp->elem_mask_tag, MB_TAG_EXCL|MB_TAG_DENSE, &int_def_val);
      if (merr != MB_SUCCESS) {
        if(ESMC_LogDefault.MsgFoundError(ESMC_RC_MOAB_ERROR,
                                         moab::ErrorCodeStr[merr], ESMC_CONTEXT, rc)) return;
      }

      // Setup elem mask value tag
      int_def_val=0; // So things are by default not masked
      merr=moab_mesh->tag_get_handle("elem_mask_val", 1, MB_TYPE_INTEGER, mbmp->elem_mask_val_tag, MB_TAG_EXCL|MB_TAG_DENSE, &int_def_val);
      if (merr != MB_SUCCESS) {
        if(ESMC_LogDefault.MsgFoundError(ESMC_RC_MOAB_ERROR,
                                         moab::ErrorCodeStr[merr], ESMC_CONTEXT, rc)) return;
      }

      // Record the fact that it has masks
      mbmp->has_elem_mask=true;
    }

    // Handle element area
    mbmp->has_elem_area=false;
    if (areaPresent == 1) { // if areas exist

      merr=moab_mesh->tag_get_handle("elem_area", 1, MB_TYPE_DOUBLE, mbmp->elem_area_tag, MB_TAG_EXCL|MB_TAG_DENSE, &dbl_def_val_one);
      if (merr != MB_SUCCESS) {
        if(ESMC_LogDefault.MsgFoundError(ESMC_RC_MOAB_ERROR,
                                         moab::ErrorCodeStr[merr], ESMC_CONTEXT, rc)) return;
      }

      // Record the fact that it has masks
      mbmp->has_elem_area=true;
    }

    // Handle element coords
    mbmp->has_elem_coords=false;
    mbmp->has_elem_orig_coords=false;
    if (elemCoordsPresent == 1) { // if coords exist

      // Add element coords field
      merr=moab_mesh->tag_get_handle("elem_coords", mbmp->sdim, MB_TYPE_DOUBLE, mbmp->elem_coords_tag, MB_TAG_EXCL|MB_TAG_DENSE, dbl_def_val);
       if (merr != MB_SUCCESS) {
        if(ESMC_LogDefault.MsgFoundError(ESMC_RC_MOAB_ERROR,
                                         moab::ErrorCodeStr[merr], ESMC_CONTEXT, rc)) return;
      }

      // If not cartesian then add original coordinates field
      if (coordSys != ESMC_COORDSYS_CART) {
        merr=moab_mesh->tag_get_handle("elem_orig_coords", orig_sdim, MB_TYPE_DOUBLE, mbmp->elem_orig_coords_tag, MB_TAG_EXCL|MB_TAG_DENSE, dbl_def_val);
        if (merr != MB_SUCCESS) {
          if(ESMC_LogDefault.MsgFoundError(ESMC_RC_MOAB_ERROR,
                                           moab::ErrorCodeStr[merr], ESMC_CONTEXT, rc)) return;
        }

        // Record the fact that it has original elem coords
        mbmp->has_elem_orig_coords=true;
      }


      // Record the fact that it has elem coords
      mbmp->has_elem_coords=true;
    }

    ESMCI_MESHCREATE_TRACE_EXIT("MBMesh addelems setup")

    ESMCI_MESHCREATE_TRACE_ENTER("MBMesh addelems split elem handling")

    // Variable indicating if any of the elements on this PET are split
    bool is_split_local=false;

    // Count the number of extra elements we need for splitting
    int num_extra_elem=0;
    int max_num_conn=0;
    int max_num_elemtris=0;
     if (parametric_dim==2) {
      int conn_pos=0;
      for (int e = 0; e < num_elems; ++e) {

        // Only count split elements
        if (elemType[e] > 4) {

          // Loop here through each set of connection looking for polybreaks to
          // figure out the size of each sub-elem
          int subelem_size=0;
          int num_elemtris=0;
          for (int i=0; i<elemType[e]; i++) {

            // Advance size of element, or start a new one
            if (elemConn[conn_pos] != MESH_POLYBREAK_IND) {
              subelem_size++;
            } else {
              // record this elem
              num_extra_elem += (subelem_size-2); // num tri = # sides-2
              num_elemtris += (subelem_size-2); // num tri = # sides-2
              if (subelem_size > max_num_conn) max_num_conn=subelem_size;
              subelem_size=0;
            }

            // next connection
            conn_pos++;
          }

          // record this elem
          num_extra_elem += (subelem_size-3); // num tri = # sides-2 - 1 (for orig elem)
          num_elemtris += (subelem_size-2); // num tri = # sides-2 (count orig elem)
          if (num_elemtris > max_num_elemtris) max_num_elemtris=num_elemtris;
          if (subelem_size > max_num_conn) max_num_conn=subelem_size;
        } else {
          conn_pos += elemType[e];
        }
      }

      // mark if mesh on this particular PET is split
      if (num_extra_elem > 0) is_split_local=true;
      
      int tot_num_extra_elem=0;
      MPI_Allreduce(&num_extra_elem,&tot_num_extra_elem,1,MPI_INT,MPI_SUM,mpi_comm);

      // If there's num_extra_elem than it's a split mesh
      if (tot_num_extra_elem>0) {
        mbmp->is_split=true;
       } else {
        mbmp->is_split=false;
      }
    } else {
      mbmp->is_split=false;
    }

    // Compute the extra element ranges
    int beg_extra_ids=0;
    if (mbmp->is_split) {
      // get maximum local elem id
       int max_id=0;
      for (int e = 0; e < num_elems; ++e) {
        if (elemId[e] > max_id) {
          max_id=elemId[e];
         }
      }

      // Calc global max id
      int global_max_id=0;
      MPI_Allreduce(&max_id,&global_max_id,1,MPI_INT,MPI_MAX,mpi_comm);

      // Set maximum of non-split ids
      mbmp->max_non_split_id=global_max_id;

      // Calc our range of extra elem ids
      beg_extra_ids=0;
      MPI_Scan(&num_extra_elem,&beg_extra_ids,1,MPI_INT,MPI_SUM,mpi_comm);

      // Remove this processor's number from the sum to get the beginning
       beg_extra_ids=beg_extra_ids-num_extra_elem;

      // Start 1 up from max
      beg_extra_ids=beg_extra_ids+global_max_id+1;

      // printf("%d# beg_extra_ids=%d end=%d\n",Par::Rank(),beg_extra_ids,beg_extra_ids+num_extra_elem-1);
    }

    ESMCI_MESHCREATE_TRACE_EXIT("MBMesh addelems split elem handling")

#if 0
    // Don't currently support split elements with element coords
    if (mbmp->is_split && elemCoordsPresent) {
      int localrc;
      if(ESMC_LogDefault.MsgFoundError(ESMC_RC_ARG_VALUE,
         "- ESMF doesn't currently support both element coords and polygons with >4 sides in the same Mesh.",
             ESMC_CONTEXT, &localrc)) throw localrc;
    }
#endif

    ESMCI_MESHCREATE_TRACE_ENTER("MBMesh addelems connectivity")


    // Get number of verts
    int num_verts = mbmp->num_verts;

    // Allocate array to make sure that there are no local nodes without a home
    std::vector<int> node_used;
    node_used.resize(num_verts, 0);


    // Error check elemConn array
    int c = 0;
    for (int e = 0; e < num_elems; ++e) {
      int nnodes = ElemType2NumNodes(mbmp->pdim,
                                     mbmp->sdim,
                                     elemType[e]);

      for (int n = 0; n < nnodes; ++n) {

        // Get 0-based node index
        int node_index=elemConn[c]-1;

         // Check elemConn
        if (node_index < 0) {
          int localrc;
          if(ESMC_LogDefault.MsgFoundError(ESMC_RC_ARG_VALUE,
           "- elemConn entries should not be less than 1 ",
                 ESMC_CONTEXT, &localrc)) throw localrc;
        }

        if (node_index > num_verts-1) {
          int localrc;
          if(ESMC_LogDefault.MsgFoundError(ESMC_RC_ARG_VALUE,
           "- elemConn entries should not be greater than number of nodes on processor ",
                 ESMC_CONTEXT, &localrc)) throw localrc;
        }

        // Mark as used
        node_used[node_index]=1;

        // Advance to next
        c++;
       }
    } // for e

    // Make sure every node used
    bool every_node_used=true;
    for (int i=0; i<num_verts; i++) {
      if (node_used[i] == 0) {
        every_node_used=false;
        break;
      }
    }

    if (!every_node_used) {
      int localrc;
      if(ESMC_LogDefault.MsgFoundError(ESMC_RC_ARG_VALUE,
          "- there are nodes on this PET that were not used in the element connectivity list ",
          ESMC_CONTEXT, &localrc)) throw localrc;
    }

    // Generate connectivity list with split elements
    // TODO: MAYBE EVENTUALLY PUT EXTRA SPLIT ONES AT END
    int num_elems_wsplit=0;
    int *elemConn_wsplit=NULL;
    int *elemType_wsplit=NULL;
    int *elemId_wsplit=NULL;
    double *elemArea_wsplit=NULL;
    double *elemCoords_wsplit=NULL;
    int *elemMaskIIArray_wsplit=NULL;
    InterArray<int> *elemMaskII_wsplit=NULL;

    if (is_split_local) {
      // New number of elements
      num_elems_wsplit=num_elems+num_extra_elem;

      // Allocate arrays to hold split lists
      elemConn_wsplit=new int[num_elemConn+3*num_extra_elem];
      elemType_wsplit=new int[num_elems_wsplit];
      elemId_wsplit=new int[num_elems_wsplit];
      if (areaPresent==1) elemArea_wsplit=new double[num_elems_wsplit];
      if (elemCoordsPresent==1) elemCoords_wsplit=new double[orig_sdim*num_elems_wsplit];

      //// Setup for split mask
      int *elemMaskIIArray=NULL;
      if (present(elemMaskII)) {

        // Get mask value array
        elemMaskIIArray=elemMaskII->array;

        int extent[1];
        elemMaskIIArray_wsplit=new int[num_elems_wsplit];

        extent[0]=num_elems_wsplit;
        elemMaskII_wsplit=new InterArray<int>(elemMaskIIArray_wsplit,1,extent);
      }


      // Allocate some temporary variables for splitting
      double *subelem_coords=new double[3*max_num_conn];
      double *subelem_dbl_buf=new double[3*max_num_conn];
      int    *subelem_int_buf=new int[max_num_conn];
      int    *subelem_tri_ind=new int[3*(max_num_conn-2)];
      double *subelem_tri_area=new double[max_num_conn-2];

      double *elemtris_area=new double[max_num_elemtris];
      int *elemtris_split_elem_pos=new int[max_num_elemtris];

      // new id counter
      int curr_extra_id=beg_extra_ids;

      // Get some useful information
      int sdim = mbmp->sdim;

      // Loop through elems generating split elems if necessary
      int conn_pos = 0;
       int split_conn_pos = 0;
      int split_elem_pos = 0;
      for (int e = 0; e < num_elems; ++e) {

        // More than 4 side, split
         if (elemType[e]>4) {

          // Init for frac calc
          int    num_elemtris=0;
          double tot_elemtris_area=0.0;

          // Loop while we're still in this element
          bool first_elem=true;
          int end_of_elem=conn_pos+elemType[e];
          while (conn_pos < end_of_elem) {

            // Skip poly breaks
            if (elemConn[conn_pos] == MESH_POLYBREAK_IND) conn_pos++;

            // Find sub-elements (may be only one)
            int subelem_size=0;
            for (int i=conn_pos; i<end_of_elem; i++) {
              if (elemConn[i] == MESH_POLYBREAK_IND) break;
              subelem_size++;
            }

            //   printf("id=%d subelem_size=%d\n",elemId[e],subelem_size);


          // Get coordinates
          int crd_pos=0;
          for (int i=0; i<elemType[e]; i++) {
            double coords[3];

            EntityHandle *vert=mbmp->verts+elemConn[conn_pos+i]-1;
            merr=moab_mesh->get_coords(vert,1,coords);
            if (merr != MB_SUCCESS) {
              if(ESMC_LogDefault.MsgFoundError(ESMC_RC_MOAB_ERROR,
                        moab::ErrorCodeStr[merr], ESMC_CONTEXT,&localrc)) throw localrc;
            }

            for (int j=0; j<sdim; j++) {
              subelem_coords[crd_pos]=coords[j];
              crd_pos++;
            }

            // printf("id=%d coord=%f %f \n",elemId[e],subelem_coords[crd_pos-2],subelem_coords[crd_pos-1]);
          }

          // Triangulate polygon
          triangulate_warea(sdim, subelem_size, subelem_coords, elemId[e],
                            subelem_dbl_buf, subelem_int_buf,
                            subelem_tri_ind, subelem_tri_area);


          // Create split element list
          int tI_pos=0;
          for (int i=0; i<subelem_size-2; i++) {
             // First id is same, others are from new ids
             if (first_elem) {
               elemId_wsplit[split_elem_pos]=elemId[e];
               first_elem=false;
             } else {
               elemId_wsplit[split_elem_pos]=curr_extra_id;
               mbmp->split_to_orig_id[curr_extra_id]=elemId[e]; // Store map of split to original id
               curr_extra_id++;
             }

            // Type is triangle
            elemType_wsplit[split_elem_pos]=3;

            // Set mask (if it exists)
            if (elemMaskIIArray !=NULL) elemMaskIIArray_wsplit[split_elem_pos]=elemMaskIIArray[e];

             // Set element coords. (if it exists)
             if (elemCoordsPresent==1) {
               double *elem_pnt=elemCoords+orig_sdim*e;
               double *elem_pnt_wsplit=elemCoords_wsplit+orig_sdim*split_elem_pos;
               for (int j=0; j<orig_sdim; j++) {
                 elem_pnt_wsplit[j]=elem_pnt[j];
               }
             }


             // Set triangle corners based on subelem_tri_ind
            elemConn_wsplit[split_conn_pos]=elemConn[conn_pos+subelem_tri_ind[tI_pos]];
            elemConn_wsplit[split_conn_pos+1]=elemConn[conn_pos+subelem_tri_ind[tI_pos+1]];
            elemConn_wsplit[split_conn_pos+2]=elemConn[conn_pos+subelem_tri_ind[tI_pos+2]];

            // Acumulate over sub-elems in one element
            elemtris_split_elem_pos[num_elemtris]=split_elem_pos;
            elemtris_area[num_elemtris]=subelem_tri_area[i];
            tot_elemtris_area += elemtris_area[num_elemtris];
            num_elemtris++;

            // printf("%d eid=%d seid=%d %d %d %d %f\n",i,elemId[e],elemId_wsplit[split_elem_pos-1],elemConn_wsplit[split_conn_pos],elemConn_wsplit[split_conn_pos+1],elemConn_wsplit[split_conn_pos+2],triFrac[i]);

            // Advance
            split_elem_pos++;
            split_conn_pos +=3;
            tI_pos +=3;
           }

           // Advance to next elemConn position
          conn_pos +=subelem_size;

           } // end of loop through sub elems

           // Loop over elem setting fracs
           if (tot_elemtris_area > 0.0) {
             for (int i=0; i<num_elemtris; i++) {
               double frac=elemtris_area[i]/tot_elemtris_area;
               int sep=elemtris_split_elem_pos[i];

               // Add frac to mesh split information
               mbmp->split_id_to_frac[elemId_wsplit[sep]]=frac;

               // Set area to fraction of original area
               if (areaPresent==1) elemArea_wsplit[sep]=elemArea[e]*frac;
             }
           } else {
             for (int i=0; i<num_elemtris; i++) {
               double frac=elemtris_area[i]/tot_elemtris_area;
               int sep=elemtris_split_elem_pos[i];

               // Add frac to mesh split information
               mbmp->split_id_to_frac[elemId_wsplit[sep]]=0.0;

               // Set area to fraction of original area
               if (areaPresent==1) elemArea_wsplit[sep]=0.0;
             }
           }

        } else { // just copy
          elemId_wsplit[split_elem_pos]=elemId[e];
          elemType_wsplit[split_elem_pos]=elemType[e];
          if (areaPresent==1) elemArea_wsplit[split_elem_pos]=elemArea[e];
          if (elemCoordsPresent==1) {
            double *elem_pnt=elemCoords+orig_sdim*e;
            double *elem_pnt_wsplit=elemCoords_wsplit+orig_sdim*split_elem_pos;
            for (int j=0; j<orig_sdim; j++) {
              elem_pnt_wsplit[j]=elem_pnt[j];
            }
          }
          if (elemMaskIIArray !=NULL) elemMaskIIArray_wsplit[split_elem_pos]=elemMaskIIArray[e];
          split_elem_pos++;
          for (int i=0; i<elemType[e]; i++) {
            elemConn_wsplit[split_conn_pos]=elemConn[conn_pos];
            split_conn_pos++;
            conn_pos++;
          }
        }
      }

      // Allocate some temporary variables for splitting
      delete [] subelem_coords;
      delete [] subelem_dbl_buf;
      delete [] subelem_int_buf;
      delete [] subelem_tri_ind;
      delete [] subelem_tri_area;
      delete [] elemtris_area;
      delete [] elemtris_split_elem_pos;

      // Use the new split list for the connection lists below
      num_elems=num_elems_wsplit;
      elemConn=elemConn_wsplit;
      elemType=elemType_wsplit;
      elemId=elemId_wsplit;
      if (areaPresent==1) elemArea=elemArea_wsplit;
      if (elemCoordsPresent==1) elemCoords=elemCoords_wsplit;

      if (present(elemMaskII)) {
        elemMaskII=elemMaskII_wsplit;
      }
    }

    ESMCI_MESHCREATE_TRACE_EXIT("MBMesh addelems connectivity")

    ESMCI_MESHCREATE_TRACE_ENTER("MBMesh addelems add")

    // Now loop the elements and add them to the mesh.
    int cur_conn = 0;
    for (int e = 0; e < num_elems; ++e) {


      // Get number of nodes in element
      int num_elem_verts=ElemType2NumNodes(mbmp->pdim,
                                           mbmp->sdim,
                                           elemType[e]);

      // Define the maximum number of verts
#define MAX_ELEM_VERTS 20
       if (num_elem_verts >MAX_ELEM_VERTS) {
        int localrc;
        if(ESMC_LogDefault.MsgFoundError(ESMC_RC_ARG_VALUE,
          "- element contains more nodes than are currently supported ",
                                         ESMC_CONTEXT, &localrc)) throw localrc;
      }

      // Connectivity array
      EntityHandle elem_verts[MAX_ELEM_VERTS];
#undef MAX_ELEM_VERTS

      // Fill the connectivity array
      for (int n = 0; n < num_elem_verts; ++n) {

        // Get 0-based vert index
        int vert_index=elemConn[cur_conn]-1;

        // Setup connectivity list
        elem_verts[n] = mbmp->verts[vert_index];

        // Advance to next
        cur_conn++;
      }

      // Get number of nodes in element
      EntityType etype=get_entity_type(mbmp->pdim,
                                       elemType[e]);

      EntityHandle new_elem;
      merr=moab_mesh->create_element(etype,elem_verts,num_elem_verts,new_elem);
      if (merr != MB_SUCCESS) {
        if(ESMC_LogDefault.MsgFoundError(ESMC_RC_MOAB_ERROR,
          moab::ErrorCodeStr[merr], ESMC_CONTEXT,&localrc)) throw localrc;
      }

       // Set global id
      merr=moab_mesh->tag_set_data(mbmp->gid_tag, &new_elem, 1, elemId+e);
      if (merr != MB_SUCCESS) {
        if(ESMC_LogDefault.MsgFoundError(ESMC_RC_MOAB_ERROR,
                    moab::ErrorCodeStr[merr], ESMC_CONTEXT,&localrc)) throw localrc;
      }

      // Set Position
      merr=moab_mesh->tag_set_data(mbmp->orig_pos_tag, &new_elem, 1, &e);
      if (merr != MB_SUCCESS) {
        if(ESMC_LogDefault.MsgFoundError(ESMC_RC_MOAB_ERROR,
                    moab::ErrorCodeStr[merr], ESMC_CONTEXT,&localrc)) throw localrc;
      }

      // Set Owner to the current pet
      merr=moab_mesh->tag_set_data(mbmp->owner_tag, &new_elem, 1, &localPet);
      if (merr != MB_SUCCESS) {
        if(ESMC_LogDefault.MsgFoundError(ESMC_RC_MOAB_ERROR,
                    moab::ErrorCodeStr[merr], ESMC_CONTEXT,&localrc)) throw localrc;
      }


      // Set elem mask value
      if (mbmp->has_elem_mask) {
        merr=moab_mesh->tag_set_data(mbmp->elem_mask_val_tag, &new_elem, 1,
                                     elemMaskII->array+e);
        if (merr != MB_SUCCESS) {
          if(ESMC_LogDefault.MsgFoundError(ESMC_RC_MOAB_ERROR,
                          moab::ErrorCodeStr[merr], ESMC_CONTEXT,&localrc)) throw localrc;
        }
      }

      // Set elem area
      if (mbmp->has_elem_area) {
        merr=moab_mesh->tag_set_data(mbmp->elem_area_tag, &new_elem, 1,
                                     elemArea+e);
        if (merr != MB_SUCCESS) {
           if(ESMC_LogDefault.MsgFoundError(ESMC_RC_MOAB_ERROR,
                          moab::ErrorCodeStr[merr], ESMC_CONTEXT,&localrc)) throw localrc;
        }
      }

      // Set elem coord
      if (mbmp->has_elem_coords) {
        // Depending on coordSys save coordinates
        if (coordSys == ESMC_COORDSYS_CART) {
          merr=moab_mesh->tag_set_data(mbmp->elem_coords_tag, &new_elem, 1,
                                       elemCoords+mbmp->sdim*e);
          if (merr != MB_SUCCESS) {
            if(ESMC_LogDefault.MsgFoundError(ESMC_RC_MOAB_ERROR,
                       moab::ErrorCodeStr[merr], ESMC_CONTEXT,&localrc)) throw localrc;
          }
        } else {
          // Save original coords
          merr=moab_mesh->tag_set_data(mbmp->elem_orig_coords_tag, &new_elem, 1,
                                       elemCoords+orig_sdim*e);
          if (merr != MB_SUCCESS) {
            if(ESMC_LogDefault.MsgFoundError(ESMC_RC_MOAB_ERROR,
                       moab::ErrorCodeStr[merr], ESMC_CONTEXT,&localrc)) throw localrc;
          }

          // Convert to Cartesian coords
          double cart_coords[3]; // 7 is the maximum dimension of ESMF grids

          // Init to 0.0 incase less than 3D
          cart_coords[0]=0.0; cart_coords[1]=0.0; cart_coords[2]=0.0;

          ESMCI_CoordSys_ConvertToCart(coordSys, orig_sdim,
                                       elemCoords+orig_sdim*e, cart_coords);
#ifdef DEBUG_ELEM_COORDS
      printf("%d# elem %d [%f, %f] - [%f,%f,%f]\n", localPet, elemId[e], elemCoords[orig_sdim*e+0], elemCoords[orig_sdim*e+1], cart_coords[0],cart_coords[1],cart_coords[2]);
#endif
          // Save Cartesian coords
          merr=moab_mesh->tag_set_data(mbmp->elem_coords_tag, &new_elem, 1,
                                       cart_coords);
          if (merr != MB_SUCCESS) {
            if(ESMC_LogDefault.MsgFoundError(ESMC_RC_MOAB_ERROR,
                       moab::ErrorCodeStr[merr], ESMC_CONTEXT,&localrc)) throw localrc;
          }

        }
      }


#if 0
      // Set elem coords in the current elem
      merr=moab_mesh->tag_set_data(mbmp->elem_coords_tag, &new_elem, 1, elem_coords);
      if (merr != MB_SUCCESS) {
        if(ESMC_LogDefault.MsgFoundError(ESMC_RC_MOAB_ERROR,
                    moab::ErrorCodeStr[merr], ESMC_CONTEXT,&localrc)) throw localrc;
      }
#endif

    } // for e

    ESMCI_MESHCREATE_TRACE_EXIT("MBMesh addelems add")

    // Set number of local elems
    mbmp->num_elems=num_elems;

    //// Setup parallel sharing ///
    // mbmp->setup_parallel();


#ifdef DEBUG_ELEM_COORDS
  {
    Range elems;
    merr=mbmp->mesh->get_entities_by_dimension(0, mbmp->pdim, elems);
    MBMESH_CHECK_ERR(merr, localrc);
    
    for(Range::const_iterator it=elems.begin(); it !=elems.end(); it++) {
      const EntityHandle *elem=&(*it);
    
      int eid;
      merr=mbmp->mesh->tag_get_data(mbmp->gid_tag, elem, 1, &eid);
      MBMESH_CHECK_ERR(merr, localrc);
      printf("getelems elem %d, [",eid);
    
      double c[3];
      merr=mbmp->mesh->tag_get_data(mbmp->elem_coords_tag, elem, 1, c);
      MBMESH_CHECK_ERR(merr, localrc);
    
      for (int i=0; i<mbmp->sdim; ++i)
        printf("%f, ", c[i]);
      printf("]\n");
    }
  }
#endif

#ifdef DEBUG_MASK
      {
        int localrc = 0;
        int merr = 0;

        int node_mask[num_verts];
        if (mbmp->has_node_mask) { 
          Range nodes;
          merr=mbmp->mesh->get_entities_by_dimension(0, 0, nodes);
          if (merr != MB_SUCCESS) throw (ESMC_RC_MOAB_ERROR);
          merr=mbmp->mesh->tag_get_data(mbmp->node_mask_val_tag, nodes, &node_mask);
          if (merr != MB_SUCCESS)
            if(ESMC_LogDefault.MsgFoundError(ESMC_RC_MOAB_ERROR,
              moab::ErrorCodeStr[merr], ESMC_CONTEXT,&localrc)) throw localrc;
        }

        printf("%d# has_node_mask = %s [", Par::Rank(), mbmp->has_node_mask ? "true" : "false");
        for (int i = 0; i < num_verts; ++i)
          printf("%d, ", node_mask[i]);
        printf("]\n");
      }
#endif

#ifdef DEBUG_OWNED
      {
        int localrc = 0;
        int merr = 0;

        int node_owners[num_verts];
        Range nodes;
        merr=mbmp->mesh->get_entities_by_dimension(0, 0, nodes);
        if (merr != MB_SUCCESS) throw (ESMC_RC_MOAB_ERROR);
        merr=mbmp->mesh->tag_get_data(mbmp->owner_tag, nodes, &node_owners);
        if (merr != MB_SUCCESS)
          if(ESMC_LogDefault.MsgFoundError(ESMC_RC_MOAB_ERROR,
            moab::ErrorCodeStr[merr], ESMC_CONTEXT,&localrc)) throw localrc;

        printf("%d# MBMesh node_owners = [", Par::Rank());
        for (int i = 0; i < num_verts; ++i)
          printf("%d, ", node_owners[i]);
        printf("]\n");
      }
#endif

  // Get rid of extra memory for split elements
  if (is_split_local) {
    if (elemConn_wsplit != NULL) delete [] elemConn_wsplit;
     if (elemType_wsplit != NULL) delete [] elemType_wsplit;
    if (elemId_wsplit != NULL) delete [] elemId_wsplit;
    if (areaPresent==1) {
      if (elemArea_wsplit != NULL) delete [] elemArea_wsplit;
    }
    if (elemCoordsPresent==1) {
      if (elemCoords_wsplit != NULL) delete [] elemCoords_wsplit;
    }

    //// Setup for split mask
    if (present(elemMaskII)) {
      if (elemMaskIIArray_wsplit != NULL) delete [] elemMaskIIArray_wsplit;
      if (elemMaskII_wsplit != NULL) delete elemMaskII_wsplit;
    }

  }

  } catch(std::exception &x) {
    // catch Mesh exception return code
    if (x.what()) {
       ESMC_LogDefault.MsgFoundError(ESMC_RC_INTNRL_BAD,
                                          x.what(), ESMC_CONTEXT, rc);
    } else {
      ESMC_LogDefault.MsgFoundError(ESMC_RC_INTNRL_BAD,
                                          "UNKNOWN", ESMC_CONTEXT, rc);
    }

    return;
  }catch(int localrc){
    // catch standard ESMF return code
    ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU, ESMC_CONTEXT, rc);
    return;
  } catch(...){
    ESMC_LogDefault.MsgFoundError(ESMC_RC_INTNRL_BAD,
      "- Caught unknown exception", ESMC_CONTEXT, rc);
     return;
  }

  // Set return code
  if (rc!=NULL) *rc = ESMF_SUCCESS;
}

void MBMesh_turnonnodemask(void **mbmpp, ESMCI::InterArray<int> *maskValuesArg,  int *rc) {
#undef  ESMC_METHOD
#define ESMC_METHOD "MBMesh_turnonnodemask()"

  int merr, localrc;

  try {

    // Initialize the parallel environment for mesh (if not already done)
    {
      int localrc;
      ESMCI::Par::Init("MESHLOG", false /* use log */,VM::getCurrent(&localrc)->getMpi_c());
      if (ESMC_LogDefault.MsgFoundError(localrc,ESMCI_ERR_PASSTHRU,ESMC_CONTEXT,NULL))
        throw localrc;  // bail out with exception
    }

    // Get Moab Mesh wrapper
    MBMesh *mbmp=reinterpret_cast<MBMesh*> (*mbmpp);

    //Get MOAB Mesh
    Interface *moab_mesh=mbmp->mesh;


    // If no mask values then leave
    if (!present(maskValuesArg)) {
      // Set return code
      if (rc!=NULL) *rc = ESMF_SUCCESS;

      // Leave
      return;
    }

    // Get mask values
    int numMaskValues=(maskValuesArg)->extent[0];
    int *ptrMaskValues=&((maskValuesArg)->array[0]);

    // If has masks
    if (mbmp->has_node_mask) {

      // Get a range containing all nodes
      Range range_node;
      merr=moab_mesh->get_entities_by_dimension(0,0,range_node);
      if (merr != MB_SUCCESS) {
        if(ESMC_LogDefault.MsgFoundError(ESMC_RC_MOAB_ERROR,
                                         moab::ErrorCodeStr[merr], ESMC_CONTEXT,&localrc)) throw localrc;
      }

      // Loop through elements setting values
      for(Range::iterator it=range_node.begin(); it !=range_node.end(); it++) {
        const EntityHandle node=*it;

        // Get mask value
        int mv;
        merr=moab_mesh->tag_get_data(mbmp->node_mask_val_tag, &node, 1, &mv);
        if (merr != MB_SUCCESS) {
          if(ESMC_LogDefault.MsgFoundError(ESMC_RC_MOAB_ERROR,
                                           moab::ErrorCodeStr[merr], ESMC_CONTEXT,&localrc)) throw localrc;
        }

        // See if mv matches any mask values
        int masked=0;
        for (int i=0; i<numMaskValues; i++) {
          int mvi=ptrMaskValues[i];
          if (mv==mvi) {
            masked=1;
            break;
          }
        }

        // Set global id
        merr=moab_mesh->tag_set_data(mbmp->node_mask_tag, &node, 1, &masked);
         if (merr != MB_SUCCESS) {
          if(ESMC_LogDefault.MsgFoundError(ESMC_RC_MOAB_ERROR,
                    moab::ErrorCodeStr[merr], ESMC_CONTEXT,&localrc)) throw localrc;
        }
      }
    }

  } catch(std::exception &x) {
    // catch Mesh exception return code
    if (x.what()) {
      ESMC_LogDefault.MsgFoundError(ESMC_RC_INTNRL_BAD,
                                            x.what(), ESMC_CONTEXT, rc);
    } else {
      ESMC_LogDefault.MsgFoundError(ESMC_RC_INTNRL_BAD,
                                            "UNKNOWN", ESMC_CONTEXT, rc);
    }

    return;
  }catch(int localrc){
    // catch standard ESMF return code
    ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU, ESMC_CONTEXT, rc);
    return;
  } catch(...){
    ESMC_LogDefault.MsgFoundError(ESMC_RC_INTNRL_BAD,
                             "- Caught unknown exception", ESMC_CONTEXT, rc);
    return;
  }

  // Set return code
  if (rc!=NULL) *rc = ESMF_SUCCESS;

}

// Turn OFF masking
 void MBMesh_turnoffnodemask(void **mbmpp, int *rc) {
#undef  ESMC_METHOD
#define ESMC_METHOD "MBMesh_turnoffnodemask()"

  int merr, localrc;

  try {

    // Initialize the parallel environment for mesh (if not already done)
    {
      int localrc;
      ESMCI::Par::Init("MESHLOG", false /* use log */,VM::getCurrent(&localrc)->getMpi_c());
      if (ESMC_LogDefault.MsgFoundError(localrc,ESMCI_ERR_PASSTHRU,ESMC_CONTEXT,NULL))
        throw localrc;  // bail out with exception
    }

    // Get Moab Mesh wrapper
    MBMesh *mbmp=reinterpret_cast<MBMesh*> (*mbmpp);

    //Get MOAB Mesh
    Interface *moab_mesh=mbmp->mesh;

    // If has masks
    if (mbmp->has_node_mask) {
      // Get a range containing all nodes
      Range range_node;
      merr=moab_mesh->get_entities_by_dimension(0,0,range_node);
      if (merr != MB_SUCCESS) {
        if(ESMC_LogDefault.MsgFoundError(ESMC_RC_MOAB_ERROR,
                                         moab::ErrorCodeStr[merr], ESMC_CONTEXT,&localrc)) throw localrc;
      }

      // Loop through elements setting values
      for(Range::iterator it=range_node.begin(); it !=range_node.end(); it++) {
        const EntityHandle node=*it;

        // unset masked value
        int masked=0;
        merr=moab_mesh->tag_set_data(mbmp->node_mask_tag, &node, 1, &masked);
        if (merr != MB_SUCCESS) {
          if(ESMC_LogDefault.MsgFoundError(ESMC_RC_MOAB_ERROR,
                    moab::ErrorCodeStr[merr], ESMC_CONTEXT,&localrc)) throw localrc;
        }

      }
    }
  } catch(std::exception &x) {
    // catch Mesh exception return code
    if (x.what()) {
      ESMC_LogDefault.MsgFoundError(ESMC_RC_INTNRL_BAD,
                                            x.what(), ESMC_CONTEXT, rc);
    } else {
      ESMC_LogDefault.MsgFoundError(ESMC_RC_INTNRL_BAD,
                                            "UNKNOWN", ESMC_CONTEXT, rc);
    }

    return;
  }catch(int localrc){
     // catch standard ESMF return code
    ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU, ESMC_CONTEXT, rc);
    return;
  } catch(...){
    ESMC_LogDefault.MsgFoundError(ESMC_RC_INTNRL_BAD,
                        "- Caught unknown exception", ESMC_CONTEXT, rc);
    return;
  }

  // Set return code
  if (rc!=NULL) *rc = ESMF_SUCCESS;

}

void MBMesh_turnonelemmask(void **mbmpp, ESMCI::InterArray<int> *maskValuesArg,  int *rc) {
#undef  ESMC_METHOD
#define ESMC_METHOD "MBMesh_turnonelemmask()"

  int merr, localrc;

  try {

    // Initialize the parallel environment for mesh (if not already done)
    {
      int localrc;
      ESMCI::Par::Init("MESHLOG", false /* use log */,VM::getCurrent(&localrc)->getMpi_c());
      if (ESMC_LogDefault.MsgFoundError(localrc,ESMCI_ERR_PASSTHRU,ESMC_CONTEXT,NULL))
        throw localrc;  // bail out with exception
    }

    // Get Moab Mesh wrapper
    MBMesh *mbmp=reinterpret_cast<MBMesh*> (*mbmpp);

    //Get MOAB Mesh
    Interface *moab_mesh=mbmp->mesh;


    // If no mask values then leave
    if (!present(maskValuesArg)) {
      // Set return code
      if (rc!=NULL) *rc = ESMF_SUCCESS;

      // Leave
      return;
    }


    // Get mask values
    int numMaskValues=(maskValuesArg)->extent[0];
    int *ptrMaskValues=&((maskValuesArg)->array[0]);

    // If has masks
    if (mbmp->has_elem_mask) {

      // Get a range containing all elements
      Range range_elem;
      merr=moab_mesh->get_entities_by_dimension(0,mbmp->pdim,range_elem);
      if (merr != MB_SUCCESS) {
        if(ESMC_LogDefault.MsgFoundError(ESMC_RC_MOAB_ERROR,
                                         moab::ErrorCodeStr[merr], ESMC_CONTEXT,&localrc)) throw localrc;
      }

      // Loop through elements setting values
      for(Range::iterator it=range_elem.begin(); it !=range_elem.end(); it++) {
        const EntityHandle elem=*it;

        // Get mask value
        int mv;
        merr=moab_mesh->tag_get_data(mbmp->elem_mask_val_tag, &elem, 1, &mv);
        if (merr != MB_SUCCESS) {
          if(ESMC_LogDefault.MsgFoundError(ESMC_RC_MOAB_ERROR,
                                           moab::ErrorCodeStr[merr], ESMC_CONTEXT,&localrc)) throw localrc;
        }

        // See if mv matches any mask values
        int masked=0;
        for (int i=0; i<numMaskValues; i++) {
          int mvi=ptrMaskValues[i];
          if (mv==mvi) {
            masked=1;
            break;
          }
        }

        // Set global id
        merr=moab_mesh->tag_set_data(mbmp->elem_mask_tag, &elem, 1, &masked);
         if (merr != MB_SUCCESS) {
          if(ESMC_LogDefault.MsgFoundError(ESMC_RC_MOAB_ERROR,
                    moab::ErrorCodeStr[merr], ESMC_CONTEXT,&localrc)) throw localrc;
        }
      }
    }

  } catch(std::exception &x) {
    // catch Mesh exception return code
    if (x.what()) {
      ESMC_LogDefault.MsgFoundError(ESMC_RC_INTNRL_BAD,
                                            x.what(), ESMC_CONTEXT, rc);
    } else {
      ESMC_LogDefault.MsgFoundError(ESMC_RC_INTNRL_BAD,
                                            "UNKNOWN", ESMC_CONTEXT, rc);
    }

    return;
  }catch(int localrc){
    // catch standard ESMF return code
    ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU, ESMC_CONTEXT, rc);
    return;
  } catch(...){
    ESMC_LogDefault.MsgFoundError(ESMC_RC_INTNRL_BAD,
                             "- Caught unknown exception", ESMC_CONTEXT, rc);
    return;
  }

  // Set return code
  if (rc!=NULL) *rc = ESMF_SUCCESS;

}

// Turn OFF masking
 void MBMesh_turnoffelemmask(void **mbmpp, int *rc) {
#undef  ESMC_METHOD
#define ESMC_METHOD "MBMesh_turnoffelemmask()"

  int merr, localrc;

  try {

    // Initialize the parallel environment for mesh (if not already done)
    {
      int localrc;
      ESMCI::Par::Init("MESHLOG", false /* use log */,VM::getCurrent(&localrc)->getMpi_c());
      if (ESMC_LogDefault.MsgFoundError(localrc,ESMCI_ERR_PASSTHRU,ESMC_CONTEXT,NULL))
        throw localrc;  // bail out with exception
    }

    // Get Moab Mesh wrapper
    MBMesh *mbmp=reinterpret_cast<MBMesh*> (*mbmpp);

    //Get MOAB Mesh
    Interface *moab_mesh=mbmp->mesh;

    // If has masks
    if (mbmp->has_elem_mask) {
      // Get a range containing all elements
      Range range_elem;
      merr=moab_mesh->get_entities_by_dimension(0,mbmp->pdim,range_elem);
      if (merr != MB_SUCCESS) {
        if(ESMC_LogDefault.MsgFoundError(ESMC_RC_MOAB_ERROR,
                                         moab::ErrorCodeStr[merr], ESMC_CONTEXT,&localrc)) throw localrc;
      }

      // Loop through elements setting values
      for(Range::iterator it=range_elem.begin(); it !=range_elem.end(); it++) {
        const EntityHandle elem=*it;

        // unset masked value
        int masked=0;
        merr=moab_mesh->tag_set_data(mbmp->elem_mask_tag, &elem, 1, &masked);
        if (merr != MB_SUCCESS) {
          if(ESMC_LogDefault.MsgFoundError(ESMC_RC_MOAB_ERROR,
                    moab::ErrorCodeStr[merr], ESMC_CONTEXT,&localrc)) throw localrc;
        }

      }
    }

  } catch(std::exception &x) {
    // catch Mesh exception return code
    if (x.what()) {
      ESMC_LogDefault.MsgFoundError(ESMC_RC_INTNRL_BAD,
                                            x.what(), ESMC_CONTEXT, rc);
    } else {
      ESMC_LogDefault.MsgFoundError(ESMC_RC_INTNRL_BAD,
                                            "UNKNOWN", ESMC_CONTEXT, rc);
    }

    return;
  }catch(int localrc){
      // catch standard ESMF return code
     ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU, ESMC_CONTEXT, rc);
    return;
  } catch(...){
    ESMC_LogDefault.MsgFoundError(ESMC_RC_INTNRL_BAD,
                        "- Caught unknown exception", ESMC_CONTEXT, rc);
    return;
  }

  // Set return code
  if (rc!=NULL) *rc = ESMF_SUCCESS;
}



void MBMesh_destroy(void **mbmpp, int *rc) {
#undef  ESMC_METHOD
#define ESMC_METHOD "MBMesh_destroy()"

  try {

    // Initialize the parallel environment for mesh (if not already done)
    int localrc;
    int rc;
    ESMCI::Par::Init("MESHLOG", false, VM::getCurrent(&localrc)->getMpi_c());
    if (ESMC_LogDefault.MsgFoundError(localrc,ESMCI_ERR_PASSTHRU,ESMC_CONTEXT,NULL))
      throw localrc;  // bail out with exception

    // Get Moab Mesh wrapper
    MBMesh *mbmp=reinterpret_cast<MBMesh*> (*mbmpp);

    // Get rid of MBMesh
    delete mbmp;

    // Set to null
    *mbmpp=NULL;

  } catch(std::exception &x) {
    // catch Mesh exception return code
     if (x.what()) {
      ESMC_LogDefault.MsgFoundError(ESMC_RC_INTNRL_BAD,
                                          x.what(), ESMC_CONTEXT, rc);
    } else {
      ESMC_LogDefault.MsgFoundError(ESMC_RC_INTNRL_BAD,
                                          "UNKNOWN", ESMC_CONTEXT, rc);
    }

    return;
  }catch(int localrc){
    // catch standard ESMF return code
    ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU, ESMC_CONTEXT, rc);
    return;
  } catch(...){
    ESMC_LogDefault.MsgFoundError(ESMC_RC_INTNRL_BAD,
      "- Caught unknown exception", ESMC_CONTEXT, rc);
    return;
  }

  // Set return code
  if (rc!=NULL) *rc = ESMF_SUCCESS;
}



void MBMesh_write(void **mbmpp, char *fname, int *rc,
    ESMCI_FortranStrLenArg nlen) {
#undef  ESMC_METHOD
#define ESMC_METHOD "MBMesh_write()"

  int localrc;

 #if 0
  // Initialize the parallel environment for mesh (if not already done)
    {
 int localrc;
 int rc;
  ESMCI::Par::Init("MESHLOG", false /* use log */,VM::getCurrent(&localrc)->getMpi_c());
 if (ESMC_LogDefault.MsgFoundError(localrc,ESMCI_ERR_PASSTHRU,ESMC_CONTEXT,NULL))
   throw localrc;  // bail out with exception
    }
#endif

  // Get localPet
  int localPet = VM::getCurrent(&localrc)->getLocalPet();
  if (ESMC_LogDefault.MsgFoundError(localrc,ESMCI_ERR_PASSTHRU,ESMC_CONTEXT,rc)) return;

  // Get petCount
  int petCount = VM::getCurrent(&localrc)->getPetCount();
  if (ESMC_LogDefault.MsgFoundError(localrc,ESMCI_ERR_PASSTHRU,ESMC_CONTEXT,rc)) return;


    // Get Moab Mesh wrapper
    MBMesh *mbmp=reinterpret_cast<MBMesh*> (*mbmpp);

    //Get MOAB Mesh
    Interface *moab_mesh=mbmp->mesh;

    // Make c format string
    char *filename = ESMC_F90toCstring(fname, nlen);

 /* XMRKX */
    // Add vtk
#define FILENAME_W_VTK_MAX 1024
    char filename_w_vtk[FILENAME_W_VTK_MAX];
    if (strlen(filename)+4 > FILENAME_W_VTK_MAX) {
        ESMC_LogDefault.MsgFoundError(ESMC_RC_ARG_RANK,
                                     " filename too long ", ESMC_CONTEXT, rc);
      return;
    }
#undef FILENAME_W_VTK_MAX

    // Write file name (add pet info if > 1 PET)
    if (petCount > 1) {
      sprintf(filename_w_vtk,"%s.%d.%d.vtk",filename,petCount,localPet);
    } else {
      sprintf(filename_w_vtk,"%s.vtk",filename);
    }

    // Call into MOAB
    int merr=moab_mesh->write_file(filename_w_vtk,NULL,NULL);
    if (merr != MB_SUCCESS) {
      if(ESMC_LogDefault.MsgFoundError(ESMC_RC_MOAB_ERROR,
                                       moab::ErrorCodeStr[merr], ESMC_CONTEXT, rc)) return;
    }

    // get rid of c format string
    delete [] filename;

    // Set return code
    if (rc!=NULL) *rc = ESMF_SUCCESS;


 }


void MBMesh_createnodedistgrid(void **mbmpp, int *ngrid, int *num_lnodes, int *rc) {

#undef  ESMC_METHOD
#define ESMC_METHOD "MBMesh_createnodedistgrid()"

  // Declare id vectors
  std::vector<int> ngids;

  try {

    // Get localPet
    int localrc;
    int localPet = VM::getCurrent(&localrc)->getLocalPet();
    if (ESMC_LogDefault.MsgFoundError(localrc,ESMCI_ERR_PASSTHRU,ESMC_CONTEXT,NULL))
      throw localrc;  // bail out with exception

    // Get Moab Mesh wrapper
    MBMesh *mbmp=reinterpret_cast<MBMesh*> (*mbmpp);

    //Get MOAB Mesh
    Interface *moab_mesh=mbmp->mesh;

    // MOAB error
    int merr;

    // Get a range containing all nodes
    Range range_node;
    merr=mbmp->mesh->get_entities_by_dimension(0,0,range_node);
    MBMESH_CHECK_ERR(merr, localrc);

    for(Range::const_iterator it=range_node.begin(); it !=range_node.end(); it++) {
      const EntityHandle *node=&(*it);

      // Get owner
      int owner;
      merr=moab_mesh->tag_get_data(mbmp->owner_tag, node, 1, &owner);
      MBMESH_CHECK_ERR(merr, localrc);

      // If owned by this processor, put in list
      if (owner==localPet) {
        // Get gid
        int gid;
        merr=moab_mesh->tag_get_data(mbmp->gid_tag, node, 1, &gid);
        MBMESH_CHECK_ERR(merr, localrc);

        // Stick in list
        ngids.push_back(gid);
      }
    }

  } catch(std::exception &x) {
    // catch Mesh exception return code
    if (x.what()) {
      ESMC_LogDefault.MsgFoundError(ESMC_RC_INTNRL_BAD,
                                          x.what(), ESMC_CONTEXT, rc);
    } else {
      ESMC_LogDefault.MsgFoundError(ESMC_RC_INTNRL_BAD,
                                          "UNKNOWN", ESMC_CONTEXT, rc);
    }

    return;
  }catch(int localrc){
    // catch standard ESMF return code
    ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU, ESMC_CONTEXT, rc);
    return;
  } catch(...){
    ESMC_LogDefault.MsgFoundError(ESMC_RC_INTNRL_BAD,
      "- Caught unknown exception", ESMC_CONTEXT, rc);
    return;
  }


  // Create the distgrids
  {
    int nsize = *num_lnodes = ngids.size();
    int rc1;

    int *indices = (nsize==0)?NULL:&ngids[0];

    FTN_X(f_esmf_getmeshdistgrid)(ngrid, &nsize, indices, &rc1);

    if (ESMC_LogDefault.MsgFoundError(rc1,
      ESMCI_ERR_PASSTHRU, ESMC_CONTEXT,
      ESMC_NOT_PRESENT_FILTER(rc))) return;
  }

  // Set return code
  if (rc!=NULL) *rc = ESMF_SUCCESS;

}

 /* XMRKX */
/**
 * Sort elements by the order in which they were originally declared
 * (which is stored by get_data_index)
 * Don't include split elements
 */

// DO THIS BETTER, HAVE A FIELD THAT CONTAINS THE POSITION IN THE FINAL ARRAY AND -1 FOR ANYTHING NOT LOCAL OR SPLIT
void getElemGIDS(MBMesh *mbmp, std::vector<int> &egids) {
#undef  ESMC_METHOD
#define ESMC_METHOD "getElemGIDS()"

  // Get localPet
  int localrc;
  int localPet = VM::getCurrent(&localrc)->getLocalPet();
  if (ESMC_LogDefault.MsgFoundError(localrc,ESMCI_ERR_PASSTHRU,ESMC_CONTEXT,NULL))
    throw localrc;  // bail out with exception

  //Get MOAB Mesh
  Interface *moab_mesh=mbmp->mesh;

  // MOAB error
  int merr;

  // Get a range containing all elements
  Range range_elem;
  merr=moab_mesh->get_entities_by_dimension(0,mbmp->pdim,range_elem);
  if (merr != MB_SUCCESS) {
    if(ESMC_LogDefault.MsgFoundError(ESMC_RC_MOAB_ERROR,
       moab::ErrorCodeStr[merr], ESMC_CONTEXT,&localrc)) throw localrc;
  }

  // Loop through elements putting into list
  std::vector<std::pair<int,int> > pos_and_gids;
  for(Range::const_iterator it=range_elem.begin(); it !=range_elem.end(); it++) {
    const EntityHandle *elemp=(&*it);

    // Get owner
    int owner;
    merr=moab_mesh->tag_get_data(mbmp->owner_tag, elemp, 1, &owner);
    if (merr != MB_SUCCESS) {
      if(ESMC_LogDefault.MsgFoundError(ESMC_RC_MOAB_ERROR,
                                       moab::ErrorCodeStr[merr], ESMC_CONTEXT,&localrc)) throw localrc;
    }

    // If owned by this processor, put in list
    if (owner==localPet) {
      // Get gid
      int gid;
      merr=moab_mesh->tag_get_data(mbmp->gid_tag, elemp, 1, &gid);
      if (merr != MB_SUCCESS) {
        if(ESMC_LogDefault.MsgFoundError(ESMC_RC_MOAB_ERROR,
                                         moab::ErrorCodeStr[merr], ESMC_CONTEXT,&localrc)) throw localrc;
      }

      // Don't do split elements
      if (mbmp->is_split && gid > mbmp->max_non_split_id) continue;

      // Get orig_pos
      int orig_pos;
      merr=moab_mesh->tag_get_data(mbmp->orig_pos_tag, elemp, 1, &orig_pos);
      if (merr != MB_SUCCESS) {
        if(ESMC_LogDefault.MsgFoundError(ESMC_RC_MOAB_ERROR,
                                         moab::ErrorCodeStr[merr], ESMC_CONTEXT,&localrc)) throw localrc;
      }

      // Stick in list
      pos_and_gids.push_back(std::make_pair(orig_pos,gid));
    }
  }

  // Put in order by original pos
  std::sort(pos_and_gids.begin(), pos_and_gids.end());

  // Fill array of element gids
  egids.clear();
  for (int i = 0; i<pos_and_gids.size(); ++i) {
    egids.push_back(pos_and_gids[i].second);

    // printf("pos=%d egids=%d\n",pos_and_gids[i].first,pos_and_gids[i].second);

  }

}


void MBMesh_createelemdistgrid(void **mbmpp, int *egrid, int *num_lelems, int *rc) {
#undef  ESMC_METHOD
#define ESMC_METHOD "MBMesh_createelemdistgrid()"

  // Declare id vectors
  std::vector<int> egids;

  try {

#if 0
  // Initialize the parallel environment for mesh (if not already done)
    {
 int localrc;
 int rc;
  ESMCI::Par::Init("MESHLOG", false /* use log */,VM::getCurrent(&localrc)->getMpi_c());
 if (ESMC_LogDefault.MsgFoundError(localrc,ESMCI_ERR_PASSTHRU,ESMC_CONTEXT,NULL))
   throw localrc;  // bail out with exception
    }
#endif

    // Get Moab Mesh wrapper
    MBMesh *mbmp=reinterpret_cast<MBMesh*> (*mbmpp);

    // Get list of elem gids in order
    getElemGIDS(mbmp, egids);

  } catch(std::exception &x) {
    // catch Mesh exception return code
    if (x.what()) {
      ESMC_LogDefault.MsgFoundError(ESMC_RC_INTNRL_BAD,
                                          x.what(), ESMC_CONTEXT, rc);
    } else {
      ESMC_LogDefault.MsgFoundError(ESMC_RC_INTNRL_BAD,
                                          "UNKNOWN", ESMC_CONTEXT, rc);
    }

    return;
  }catch(int localrc){
    // catch standard ESMF return code
    ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU, ESMC_CONTEXT, rc);
    return;
  } catch(...){
    ESMC_LogDefault.MsgFoundError(ESMC_RC_INTNRL_BAD,
      "- Caught unknown exception", ESMC_CONTEXT, rc);
    return;
  }

  {
    int esize = *num_lelems = egids.size();
    int rc1;

    int *indices = (esize==0)?NULL:&egids[0];

    FTN_X(f_esmf_getmeshdistgrid)(egrid, &esize, indices, &rc1);

    if(ESMC_LogDefault.MsgFoundError(rc1,
      ESMCI_ERR_PASSTHRU, ESMC_CONTEXT,
      ESMC_NOT_PRESENT_FILTER(rc))) return;
  }

  // Set return code
  if (rc!=NULL) *rc = ESMF_SUCCESS;
}


// DO THIS BETTER, HAVE A FIELD THAT CONTAINS THE POSITION IN THE FINAL ARRAY AND -1 FOR ANYTHING NOT LOCAL OR SPLIT
void getElems(void **mbmpp, std::vector<EntityHandle> &ehs) {
#undef  ESMC_METHOD
#define ESMC_METHOD "MBMesh_getElems()"

  // Get localPet
  int localrc;
  int localPet = VM::getCurrent(&localrc)->getLocalPet();
  if (ESMC_LogDefault.MsgFoundError(localrc,ESMCI_ERR_PASSTHRU,ESMC_CONTEXT,NULL))
    throw localrc;  // bail out with exception

  // Get Moab Mesh wrapper
  MBMesh *mbmp=reinterpret_cast<MBMesh*> (*mbmpp);

  //Get MOAB Mesh
  Interface *moab_mesh=mbmp->mesh;

  // MOAB error
  int merr;


  // Get a range containing all elements
  Range range_elem;
  merr=moab_mesh->get_entities_by_dimension(0,mbmp->pdim,range_elem);
  if (merr != MB_SUCCESS) {
    if(ESMC_LogDefault.MsgFoundError(ESMC_RC_MOAB_ERROR,
       moab::ErrorCodeStr[merr], ESMC_CONTEXT,&localrc)) throw localrc;
  }

  // Loop through elements putting into list
  std::vector<std::pair<int,EntityHandle> > pos_and_elems;
  for(Range::const_iterator it=range_elem.begin(); it !=range_elem.end(); it++) {
    const EntityHandle *elemp=(&*it);
    EntityHandle elem=*it;

    // Get owner
    int owner;
    merr=moab_mesh->tag_get_data(mbmp->owner_tag, elemp, 1, &owner);
    if (merr != MB_SUCCESS) {
      if(ESMC_LogDefault.MsgFoundError(ESMC_RC_MOAB_ERROR,
                                       moab::ErrorCodeStr[merr], ESMC_CONTEXT,&localrc)) throw localrc;
    }

    // If owned by this processor, put in list
    if (owner==localPet) {
      // Get gid
      int gid;
      merr=moab_mesh->tag_get_data(mbmp->gid_tag, elemp, 1, &gid);
      if (merr != MB_SUCCESS) {
        if(ESMC_LogDefault.MsgFoundError(ESMC_RC_MOAB_ERROR,
                                         moab::ErrorCodeStr[merr], ESMC_CONTEXT,&localrc)) throw localrc;
      }

      // Get orig_pos
      int orig_pos;
      merr=moab_mesh->tag_get_data(mbmp->orig_pos_tag, elemp, 1, &orig_pos);
      if (merr != MB_SUCCESS) {
        if(ESMC_LogDefault.MsgFoundError(ESMC_RC_MOAB_ERROR,
                                         moab::ErrorCodeStr[merr], ESMC_CONTEXT,&localrc)) throw localrc;
      }

      // Stick in list
      pos_and_elems.push_back(std::make_pair(orig_pos,elem));
    }
  }

  // Put in order by original pos
  std::sort(pos_and_elems.begin(), pos_and_elems.end());

  // Fill array of element gids
  ehs.clear();
  for (int i = 0; i<pos_and_elems.size(); ++i) {
    ehs.push_back(pos_and_elems[i].second);

    // printf("pos=%d egids=%d\n",pos_and_gids[i].first,pos_and_gids[i].second);

  }
}


void MBMesh_getlocalelemcoords(void **mbmpp, double *ecoords,
                               int *_orig_sdim, int *rc)
{
#undef  ESMC_METHOD
#define ESMC_METHOD "MBMesh_getlocalelemcoords()"

  int localrc,merr;
    try {

      // Get Moab Mesh wrapper
      MBMesh *mbmp=reinterpret_cast<MBMesh*> (*mbmpp);

      // Make sure that there are element coords
      if (!mbmp->has_elem_coords) {
        if(ESMC_LogDefault.MsgFoundError(ESMC_RC_ARG_WRONG,
                                         "- this mesh doesn't contain element coordinates.",
                                         ESMC_CONTEXT, &localrc)) throw localrc;
      }

      //Get MOAB Mesh
      Interface *moab_mesh=mbmp->mesh;

      // Get original spatial dim
      int orig_sdim=*_orig_sdim;

      // Declare id vector
      std::vector<EntityHandle> ehs;

      // Get local elems in correct order
      getElems(mbmpp, ehs);

      // Loop through elements and put coordss into array
      if (mbmp->has_elem_orig_coords) {
        for (int i=0; i<ehs.size(); i++) {
          // Get element gid
          EntityHandle elem=ehs[i];

          // Get orig_pos
          merr=moab_mesh->tag_get_data(mbmp->elem_orig_coords_tag,
                                       &elem, 1, ecoords+orig_sdim*i);
          if (merr != MB_SUCCESS) {
            if(ESMC_LogDefault.MsgFoundError(ESMC_RC_MOAB_ERROR,
                                             moab::ErrorCodeStr[merr], ESMC_CONTEXT,&localrc)) throw localrc;
          }
        }
      } else {
        for (int i=0; i<ehs.size(); i++) {
          // Get element gid
          EntityHandle elem=ehs[i];

          // Get orig_pos
          merr=moab_mesh->tag_get_data(mbmp->elem_coords_tag,
                                       &elem, 1, ecoords+orig_sdim*i);
          if (merr != MB_SUCCESS) {
            if(ESMC_LogDefault.MsgFoundError(ESMC_RC_MOAB_ERROR,
                                             moab::ErrorCodeStr[merr], ESMC_CONTEXT,&localrc)) throw localrc;
          }
        }
      }

    } catch(int localrc) {
        // catch standard ESMF return code
        ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU, ESMC_CONTEXT, rc);
        if (rc!=NULL) *rc = localrc;
        return;
    } catch(...) {
        localrc = ESMC_RC_INTNRL_BAD;
        ESMC_LogDefault.MsgFoundError(localrc,
            "- Caught unknown exception", ESMC_CONTEXT, rc);
        if (rc!=NULL) *rc = localrc;
        return;
    }

    // Set return code
    if (rc!=NULL) *rc = ESMF_SUCCESS;
}


void MBMesh_getarea(void **mbmpp, int *num_elem, double *elem_areas, int *rc) {
#undef  ESMC_METHOD
#define ESMC_METHOD "MBMesh_getarea()"

  // Declare polygon information
#define  MAX_NUM_POLY_COORDS  60
#define  MAX_NUM_POLY_NODES_2D  30  // MAX_NUM_POLY_COORDS/2
#define  MAX_NUM_POLY_NODES_3D  20  // MAX_NUM_POLY_COORDS/3
  int num_poly_nodes;
  double poly_coords[MAX_NUM_POLY_COORDS];
  double tmp_coords[MAX_NUM_POLY_COORDS];


  try {

#if 0
    // Initialize the parallel environment for mesh (if not already done)
    {
      int localrc;
      ESMCI::Par::Init("MESHLOG", false /* use log */,VM::getCurrent(&localrc)->getMpi_c());
      if (ESMC_LogDefault.MsgFoundError(localrc,ESMCI_ERR_PASSTHRU,ESMC_CONTEXT,NULL))
        throw localrc;  // bail out with exception
    }
#endif

    // Declare id vector
    std::vector<EntityHandle> ehs;

    // get elem ids
    // TODO: IN FUTURE MAYBE JUST USE DATA INDEX DIRECTY, ALTHOUGH THEN HAVE TO STICK
    //       SPLIT ELEMENTS AT END
    getElems(mbmpp, ehs);


    // If there are no elements then leave
    if (ehs.empty()) {
      if (rc!=NULL) *rc = ESMF_SUCCESS;
      return;
    }

    // Check size
    if (*num_elem != ehs.size()) {
      Throw() << "Number of elements doesn't match size of input array for areas";
    }


    // Get Moab Mesh wrapper
    MBMesh *mbmp=reinterpret_cast<MBMesh*> (*mbmpp);

    //Get MOAB Mesh
    Interface *moab_mesh=mbmp->mesh;

    // MOAB error
    int merr;


    // Get dimensions
    int sdim=mbmp->sdim;
    int pdim=mbmp->pdim;


    // Put areas into array
    if (mbmp->has_elem_area) {

      merr=moab_mesh->tag_get_data(mbmp->elem_area_tag, &ehs[0], ehs.size(), elem_areas);
      if (merr != MB_SUCCESS) {
        int localrc;
        if(ESMC_LogDefault.MsgFoundError(ESMC_RC_MOAB_ERROR,
                                         moab::ErrorCodeStr[merr], ESMC_CONTEXT,&localrc)) throw localrc;
      }

    } else {
      for (int i=0; i<ehs.size(); i++) {

        // Get element
        EntityHandle elem=ehs[i];

        // Compute area depending on dimensions
        double area;
        if (pdim==2) {
          if (sdim==2) {
            MBMesh_get_elem_coords(mbmp, elem, MAX_NUM_POLY_NODES_2D, &num_poly_nodes, poly_coords);
            remove_0len_edges2D(&num_poly_nodes, poly_coords);
            area=area_of_flat_2D_polygon(num_poly_nodes, poly_coords);
          } else if (sdim==3) {
            MBMesh_get_elem_coords(mbmp, elem, MAX_NUM_POLY_NODES_3D, &num_poly_nodes, poly_coords);
            //get_elem_coords_3D_ccw(&elem, cfield, MAX_NUM_POLY_NODES_3D, tmp_coords, &num_poly_nodes, poly_coords);
            remove_0len_edges3D(&num_poly_nodes, poly_coords);
            area=great_circle_area(num_poly_nodes, poly_coords);
          }
        } else if (pdim==3) {
          if (sdim==3) {
            Throw() << "Meshes with parametric dimension == 3 and spatial dimension = 3 not supported in MOAB";
            // Phedra tmp_phedra=create_phedra_from_elem(&elem, cfield);
            //area=tmp_phedra.calc_volume();
          } else {
            Throw() << "Meshes with parametric dimension == 3, but spatial dim != 3 not supported for computing areas";
          }
        } else {
          Throw() << "Meshes with parametric dimension != 2 or 3 not supported for computing areas";
        }

        // Put area into area array
        elem_areas[i]=area;
      }
    }



#if 0
    // Add in the split elements
    if (mesh.is_split) {
      std::map<int,int> id_to_index;
      for (int i=0; i<egids.size(); i++) {
        id_to_index[egids[i]]=i;
      }

      // Iterate through split elements adding in area
      Mesh::iterator ei = mesh.elem_begin(), ee = mesh.elem_end();
      for (; ei != ee; ++ei) {
        MeshObj &elem = *ei;

        // Don't do non-local elements
        if (!GetAttr(elem).is_locally_owned()) continue;

        // Get the element id
        int eid=elem.get_id();

        // Skip non-split elements
        if (!(eid > mesh.max_non_split_id)) continue;

        // Compute area depending on dimensions
        double area;
        if (pdim==2) {
          if (sdim==2) {
            get_elem_coords_2D_ccw(&elem, cfield, MAX_NUM_POLY_NODES_2D, tmp_coords, &num_poly_nodes, poly_coords);
            remove_0len_edges2D(&num_poly_nodes, poly_coords);
            area=area_of_flat_2D_polygon(num_poly_nodes, poly_coords);
          } else if (sdim==3) {
            get_elem_coords_3D_ccw(&elem, cfield, MAX_NUM_POLY_NODES_3D, tmp_coords, &num_poly_nodes, poly_coords);
            remove_0len_edges3D(&num_poly_nodes, poly_coords);
            area=great_circle_area(num_poly_nodes, poly_coords);
          }
        } else if (pdim==3) {
          if (sdim==3) {
            Phedra tmp_phedra=create_phedra_from_elem(&elem, cfield);
            area=tmp_phedra.calc_volume();
          } else {
            Throw() << "Meshes with parametric dimension == 3, but spatial dim != 3 not supported for computing areas";
          }
        } else {
          Throw() << "Meshes with parametric dimension != 2 or 3 not supported for computing areas";
        }

        // Get original id
        int orig_id=mesh.split_to_orig_id[eid];

        // Get index
        int index=id_to_index[orig_id];

        // Add area to what's already there
        elem_areas[index] += area;
      }
    }
#endif

  } catch(std::exception &x) {
    // catch Mesh exception return code
    if (x.what()) {
      ESMC_LogDefault.MsgFoundError(ESMC_RC_INTNRL_BAD,
                                          x.what(), ESMC_CONTEXT, rc);
    } else {
      ESMC_LogDefault.MsgFoundError(ESMC_RC_INTNRL_BAD,
                                          "UNKNOWN", ESMC_CONTEXT, rc);
    }

    return;
  }catch(int localrc){
    // catch standard ESMF return code
    ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU, ESMC_CONTEXT, rc);
    return;
  } catch(...){
    ESMC_LogDefault.MsgFoundError(ESMC_RC_INTNRL_BAD,
      "- Caught unknown exception", ESMC_CONTEXT, rc);
    return;
  }



  // Set return code
  if (rc!=NULL) *rc = ESMF_SUCCESS;


  // Declare polygon information
#undef  MAX_NUM_POLY_COORDS
#undef  MAX_NUM_POLY_NODES_2D
#undef  MAX_NUM_POLY_NODES_3D

}

// DO THIS BETTER, HAVE A FIELD THAT CONTAINS THE POSITION IN THE FINAL ARRAY AND -1 FOR ANYTHING NOT LOCAL OR SPLIT
void getNodes(void **mbmpp, std::vector<EntityHandle> &nodes) {
#undef  ESMC_METHOD
#define ESMC_METHOD "getNodes()"

  // Get localPet
  int localrc;
  int localPet = VM::getCurrent(&localrc)->getLocalPet();
  if (ESMC_LogDefault.MsgFoundError(localrc,ESMCI_ERR_PASSTHRU,ESMC_CONTEXT,NULL))
    throw localrc;  // bail out with exception

  // Get Moab Mesh wrapper
  MBMesh *mbmp=reinterpret_cast<MBMesh*> (*mbmpp);

  //Get MOAB Mesh
  Interface *moab_mesh=mbmp->mesh;

  // MOAB error
  int merr;


  // Get a range containing all nodes
  Range range_node;
  merr=moab_mesh->get_entities_by_dimension(0,0,range_node);
  if (merr != MB_SUCCESS) {
    if(ESMC_LogDefault.MsgFoundError(ESMC_RC_MOAB_ERROR,
       moab::ErrorCodeStr[merr], ESMC_CONTEXT,&localrc)) throw localrc;
  }

  // Loop through nodes putting into list
  std::vector<std::pair<int,EntityHandle> > pos_and_nodes;
  for(Range::const_iterator it=range_node.begin(); it !=range_node.end(); it++) {
    const EntityHandle *nodep=(&*it);
    EntityHandle node=*it;

    // Get owner
    int owner;
    merr=moab_mesh->tag_get_data(mbmp->owner_tag, nodep, 1, &owner);
    if (merr != MB_SUCCESS) {
      if(ESMC_LogDefault.MsgFoundError(ESMC_RC_MOAB_ERROR,
                                       moab::ErrorCodeStr[merr], ESMC_CONTEXT,&localrc)) throw localrc;
    }

    // If owned by this processor, put in list
    if (owner==localPet) {
      // Get gid
      int gid;
      merr=moab_mesh->tag_get_data(mbmp->gid_tag, nodep, 1, &gid);
      if (merr != MB_SUCCESS) {
        if(ESMC_LogDefault.MsgFoundError(ESMC_RC_MOAB_ERROR,
                                         moab::ErrorCodeStr[merr], ESMC_CONTEXT,&localrc)) throw localrc;
      }

      // Get orig_pos
      int orig_pos;
      merr=moab_mesh->tag_get_data(mbmp->orig_pos_tag, nodep, 1, &orig_pos);
      if (merr != MB_SUCCESS) {
        if(ESMC_LogDefault.MsgFoundError(ESMC_RC_MOAB_ERROR,
                                         moab::ErrorCodeStr[merr], ESMC_CONTEXT,&localrc)) throw localrc;
      }

      // Stick in list
      pos_and_nodes.push_back(std::make_pair(orig_pos,node));
    }
  }

  // Put in order by original pos
  std::sort(pos_and_nodes.begin(), pos_and_nodes.end());

  // Fill array of node entities
  nodes.clear();
  for (int i = 0; i<pos_and_nodes.size(); ++i) {
    nodes.push_back(pos_and_nodes[i].second);

    // printf("pos=%d ngids=%d\n",pos_and_gids[i].first,pos_and_gids[i].second);

  }
}

void MBMesh_getlocalcoords(void **mbmpp, double *ncoords, int *_orig_sdim, int *rc)
{
#undef  ESMC_METHOD
#define ESMC_METHOD "MBMesh_getlocalcoords()"

  try {
    // Get Moab Mesh wrapper
    MBMesh *mbmp=reinterpret_cast<MBMesh*> (*mbmpp);

    //Get MOAB Mesh
    Interface *moab_mesh=mbmp->mesh;

    // MOAB error
    int merr;
    int localrc;

    // Get dimensions
    int sdim=mbmp->sdim;
    int pdim=mbmp->pdim;


    // Get original spatial dim
    int orig_sdim=*_orig_sdim;

    // Declare id vector
    std::vector<EntityHandle> nodes;

    // Get local nodes in correct order
    getNodes(mbmpp, nodes);

    // Loop through nodes and put coords into array
    if (mbmp->has_node_orig_coords) {
      for (int i=0; i<nodes.size(); i++) {
        // Get node
        EntityHandle node=nodes[i];

        // Get coords
        merr=moab_mesh->tag_get_data(mbmp->node_orig_coords_tag,
                                     &node, 1, ncoords+orig_sdim*i);
        if (merr != MB_SUCCESS) {
          if(ESMC_LogDefault.MsgFoundError(ESMC_RC_MOAB_ERROR,
                                           moab::ErrorCodeStr[merr], ESMC_CONTEXT,&localrc)) throw localrc;
        }
      }
    } else {
      for (int i=0; i<nodes.size(); i++) {
        // Get node
        EntityHandle node=nodes[i];

        // Get coords
        merr=moab_mesh->get_coords(&node, 1, ncoords+orig_sdim*i);
        if (merr != MB_SUCCESS) {
          if(ESMC_LogDefault.MsgFoundError(ESMC_RC_MOAB_ERROR,
                                           moab::ErrorCodeStr[merr], ESMC_CONTEXT,&localrc)) throw localrc;
        }
      }
    }



  } catch(std::exception &x) {
    // catch Mesh exception return code
    if (x.what()) {
      ESMC_LogDefault.MsgFoundError(ESMC_RC_INTNRL_BAD,
                                          x.what(), ESMC_CONTEXT, rc);
    } else {
      ESMC_LogDefault.MsgFoundError(ESMC_RC_INTNRL_BAD,
                                          "UNKNOWN", ESMC_CONTEXT, rc);
    }

    return;
  }catch(int localrc){
    // catch standard ESMF return code
    ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU, ESMC_CONTEXT, rc);
    return;
  } catch(...){
    ESMC_LogDefault.MsgFoundError(ESMC_RC_INTNRL_BAD,
      "- Caught unknown exception", ESMC_CONTEXT, rc);
    return;
  }

  // Set return code
  if (rc!=NULL) *rc = ESMF_SUCCESS;

}

// Set data in Array based on typekind
template <class TYPE>
void MBMesh_set_Array_data(LocalArray *localArray, int index, ESMC_TypeKind_Flag typekind, TYPE data) {

  if (typekind == ESMC_TYPEKIND_I4) {
    ESMC_I4 data_i4=static_cast<ESMC_I4>(data);
    localArray->setData(&index, data_i4);
  } else if (typekind == ESMC_TYPEKIND_R4) {
    ESMC_R4 data_r4=static_cast<ESMC_R4>(data);
    localArray->setData(&index, data_r4);
  } else if (typekind == ESMC_TYPEKIND_R8) {
    ESMC_R8 data_r8=static_cast<ESMC_R8>(data);
    localArray->setData(&index, data_r8);
  } else {
    int localrc;
    ESMC_LogDefault.MsgFoundError(ESMC_RC_ARG_INCOMP,
                                  " unsupported typekind in Array.",
                                  ESMC_CONTEXT, &localrc);
    throw localrc;
  }
}

template void MBMesh_set_Array_data(LocalArray *localArray, int index, ESMC_TypeKind_Flag typekind, double data);

template void MBMesh_set_Array_data(LocalArray *localArray, int index, ESMC_TypeKind_Flag typekind, int data);



void MBMesh_geteleminfointoarray(void *vmbmp,
                                 ESMCI::DistGrid *elemDistgrid, 
                                 int numElemArrays,
                                 int *infoTypeElemArrays, 
                                 ESMCI::Array **elemArrays, 
                                 int *rc)
#undef  ESMC_METHOD
#define ESMC_METHOD "MBMesh_geteleminfointoarray()"

{
  // Must match with ESMF_MeshGet()
#define INFO_TYPE_ELEM_ARRAYS_MASK 1
#define INFO_TYPE_ELEM_ARRAYS_AREA 2
#define INFO_TYPE_ELEM_ARRAYS_MAX  2

    int localrc;
    try {

        // Initialize the parallel environment for mesh (if not already done)
        ESMCI::Par::Init("MESHLOG", false /* use log */,VM::getCurrent(&localrc)->getMpi_c());
        if (ESMC_LogDefault.MsgFoundError(localrc,ESMCI_ERR_PASSTHRU,ESMC_CONTEXT,NULL))
            throw localrc;

        // Make sure that incoming Array distgrids match element distgrid
        for (int i=0; i<numElemArrays; i++) {

          // Get match
          DistGridMatch_Flag matchflag=DistGrid::match(elemArrays[i]->getDistGrid(),elemDistgrid,&localrc);
          if (ESMC_LogDefault.MsgFoundError(localrc,ESMCI_ERR_PASSTHRU,ESMC_CONTEXT,NULL)) throw localrc;

          // Complain if it doesn't match sufficiently
          if ((matchflag != DISTGRIDMATCH_EXACT) && (matchflag != DISTGRIDMATCH_ALIAS)) {
            ESMC_LogDefault.MsgFoundError(ESMC_RC_ARG_INCOMP,
                                          " DistGrid in element information Array doesn't match Mesh element DistGrid.",
                                          ESMC_CONTEXT, &localrc);
            throw localrc;
          }
        }

        // Get Moab Mesh wrapper
        MBMesh *mbmp=reinterpret_cast<MBMesh*>(vmbmp);


        // Get the fields, Arrays for the various types of info
        ESMCI::Array *elem_mask_Array=NULL;
        ESMCI::Array *elem_area_Array=NULL;

        for (int i=0; i<numElemArrays; i++) {
          if (infoTypeElemArrays[i] == INFO_TYPE_ELEM_ARRAYS_MASK) { 
            if (!mbmp->has_elem_mask) {
              ESMC_LogDefault.MsgFoundError(ESMC_RC_ARG_INCOMP,
                                            " mesh doesn't contain element mask information.",
                                            ESMC_CONTEXT, &localrc);
              throw localrc;
            }

            // Get array pointer
            elem_mask_Array=elemArrays[i];

            // Complain if the array has more than rank 1                                 
            if (elem_mask_Array->getRank() != 1) Throw() << "this call currently can't handle Array rank != 1";
          }

          if (infoTypeElemArrays[i] == INFO_TYPE_ELEM_ARRAYS_AREA) { 
            if (!mbmp->has_elem_area) {
              ESMC_LogDefault.MsgFoundError(ESMC_RC_ARG_INCOMP,
                                            " mesh doesn't contain element area information.",
                                            ESMC_CONTEXT, &localrc);
              throw localrc;
            }

            // Get array pointer
            elem_area_Array=elemArrays[i];

            // Complain if the array has more than rank 1                                 
            if (elem_area_Array->getRank() != 1) Throw() << "this call currently can't handle Array rank != 1";

            // Complain if the Mesh is split 
            if (mbmp->is_split) Throw() << "this call currently can't handle a mesh containing elems with > 4 corners";
          }
        }


        // Get elems
        Range elems;
        mbmp->get_all_elems(elems);

        // TODO: MAYBE HAVE THE LIST OF LOCAL elemhandles in order in the mbmesh, that way you could
        //     probably just read/write them quickly in a chunk using one of the MOAB subroutines. 
        //     However, until then, this is a good way to do it. 

        // Loop and set up gid_to_elem_map
        std::map<int,EntityHandle> gid_to_elem_map;
        for (Range::iterator it=elems.begin(); it !=elems.end(); it++) {
          EntityHandle elem=*it;
          
          // Get node global id
          int gid=mbmp->get_gid(elem);
          
          // Add to map
          gid_to_elem_map[gid]=elem;
        }


        // Get LocalDeCount
        int localDECount=elemDistgrid->getDELayout()->getLocalDeCount();

        // Loop filling local DEs
        for (int lDE=0; lDE<localDECount; lDE++) {

          // Get sequence indices
          std::vector<int> seqIndexList;
          elemDistgrid->fillSeqIndexList(seqIndexList, lDE, 1);


          // Get mask if needed
          if (elem_mask_Array) {
            // Get the array info
            LocalArray *localArray=(elem_mask_Array->getLocalarrayList())[lDE];

            // Get localDE lower bound                                                    
            int lbound=(elem_mask_Array->getComputationalLBound())[lDE]; // (assumes array rank is 1)                                                                          

            // Typekind
            ESMC_TypeKind_Flag typekind=elem_mask_Array->getTypekind();

            // Loop seqIndices
            for (int i=0; i<seqIndexList.size(); i++) {
              int si=seqIndexList[i];

              // Get elem with si as gid
              std::map<int,EntityHandle>::iterator mi =  gid_to_elem_map.find(si);
              
              // If it doesn't exist, then go to next
              if (mi == gid_to_elem_map.end()) {
                Throw() << "element with that id not found in mesh";
              }
              
              // Get elem 
              EntityHandle elem=mi->second;

              // Get elem mask value
              int mask_val=mbmp->get_elem_mask_val(elem);
         
              // Location in array
              int index=i+lbound;
              
              // Convert and set data
              MBMesh_set_Array_data(localArray, index, typekind, mask_val);
            }
          }

          // Get mask if needed
          if (elem_area_Array) {
            // Get the array info
            LocalArray *localArray=(elem_area_Array->getLocalarrayList())[lDE];

            // Get localDE lower bound                                                    
            int lbound=(elem_area_Array->getComputationalLBound())[lDE]; // (assumes array rank is 1)                                                                          
            // Typekind
            ESMC_TypeKind_Flag typekind=elem_area_Array->getTypekind();

            // Loop seqIndices
            for (int i=0; i<seqIndexList.size(); i++) {
              int si=seqIndexList[i];

              // Get elem with si as gid
              std::map<int,EntityHandle>::iterator mi =  gid_to_elem_map.find(si);
              
              // If it doesn't exist, then go to next
              if (mi == gid_to_elem_map.end()) {
                Throw() << "element with that id not found in mesh";
              }
              
              // Get elem 
              EntityHandle elem=mi->second;

              // Get elem area
              double area= mbmp->get_elem_area(elem);
         
              // Location in array
              int index=i+lbound;
              
              // Convert and set data
              MBMesh_set_Array_data(localArray, index, typekind, area);
            }
          }
        }

    } catch(std::exception &x) {
        // catch Mesh exception return code
        if (x.what()) {
            localrc = ESMC_RC_INTNRL_BAD;
            ESMC_LogDefault.MsgFoundError(localrc, x.what(), ESMC_CONTEXT, rc);
    } else {
        localrc = ESMC_RC_INTNRL_BAD;
        ESMC_LogDefault.MsgFoundError(localrc, "UNKNOWN", ESMC_CONTEXT, rc);
    }
    if (rc!=NULL) *rc = localrc;
    return;
    } catch(int localrc) {
        // catch standard ESMF return code
        ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU, ESMC_CONTEXT, rc);
        if (rc!=NULL) *rc = localrc;
        return;
    } catch(...) {
        localrc = ESMC_RC_INTNRL_BAD;
        ESMC_LogDefault.MsgFoundError(localrc,
            "- Caught unknown exception", ESMC_CONTEXT, rc);
        if (rc!=NULL) *rc = localrc;
        return;
    }

    // Set return code
    if (rc!=NULL) *rc = ESMF_SUCCESS;

#undef INFO_TYPE_ELEM_ARRAYS_MASK 
#undef INFO_TYPE_ELEM_ARRAYS_AREA 
#undef INFO_TYPE_ELEM_ARRAYS_MAX  
}


void MBMesh_serialize(void **mbmpp, char *buffer, int *length, 
                      int *offset, ESMC_InquireFlag *inquireflag, int *rc,
                      ESMCI_FortranStrLenArg buffer_l) {
#undef  ESMC_METHOD
#define ESMC_METHOD "mbmesh_serialize()"

  try {

    // Initialize the parallel environment for mesh (if not already done)
    {
      int localrc;
      ESMCI::Par::Init("MESHLOG", false /* use log */,VM::getCurrent(&localrc)->getMpi_c());
      if (ESMC_LogDefault.MsgFoundError(localrc,ESMCI_ERR_PASSTHRU,ESMC_CONTEXT,NULL))
      throw localrc;  // bail out with exception
    }

    int *ip;


    // Initialize return code; assume routine not implemented
    if (rc) *rc = ESMC_RC_NOT_IMPL;

    // Get Moab Mesh wrapper
    MBMesh *mbmp=reinterpret_cast<MBMesh*> (*mbmpp);

    //Get MOAB Mesh
    Interface *mesh=mbmp->mesh;

// printf("%d# MBMesh_serialize - 0\n", Par::Rank());

    // Calc Size
    int size = 4*sizeof(int);

    // TODO: verify length > vars.
    if (*inquireflag != ESMF_INQUIREONLY) {
      if ((*length - *offset) < size) {
        ESMC_LogDefault.MsgFoundError(ESMC_RC_ARG_BAD,
          "Buffer too short to add Mesh object", ESMC_CONTEXT, rc);
         return;
      }
    }
    
// printf("%d# MBMesh_serialize - 1\n", Par::Rank());

    // Save integers
    ip= (int *)(buffer + *offset);
    if (*inquireflag != ESMF_INQUIREONLY) {
      *ip++ = mbmp->sdim;
      *ip++ = mbmp->pdim;
      *ip++ = mbmp->orig_sdim;
      *ip++ = mbmp->coordsys;
    }
    
// printf("%d# MBMesh_serialize - 2\n", Par::Rank());

    // Adjust offset
    *offset += size;

// printf("%d# MBMesh_serialize - 3\n", Par::Rank());


  } catch(std::exception &x) {
    // catch Mesh exception return code
    if (x.what()) {
      ESMC_LogDefault.MsgFoundError(ESMC_RC_INTNRL_BAD,
                                            x.what(), ESMC_CONTEXT, rc);
    } else {
      ESMC_LogDefault.MsgFoundError(ESMC_RC_INTNRL_BAD,
                                            "UNKNOWN", ESMC_CONTEXT, rc);
    }

    return;
  }catch(int localrc){
    // catch standard ESMF return code
    ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU, ESMC_CONTEXT, rc);
    return;
  } catch(...){
    ESMC_LogDefault.MsgFoundError(ESMC_RC_INTNRL_BAD,
                           "- Caught unknown exception", ESMC_CONTEXT, rc);
    return;
  }

// printf("%d# MBMesh_serialize - 4\n", Par::Rank());

  if (rc!=NULL) *rc=ESMF_SUCCESS;

}

void MBMesh_deserialize(void **mbmpp, char *buffer, int *offset, int *rc,
                        ESMCI_FortranStrLenArg buffer_l) {
#undef  ESMC_METHOD
#define ESMC_METHOD "mbmesh_deserialize()"

  try {

    // Initialize the parallel environment for mesh (if not already done)
    {
      int localrc;
      ESMCI::Par::Init("MESHLOG", false /* use log */,VM::getCurrent(&localrc)->getMpi_c());
      if (ESMC_LogDefault.MsgFoundError(localrc,ESMCI_ERR_PASSTHRU,ESMC_CONTEXT,NULL))
      throw localrc;  // bail out with exception
    }

// printf("%d# MBMesh_deserialize - 0\n", Par::Rank());

    int localrc;
    int *ip;
    int localsize = 0;

    // Initialize return code; assume routine not implemented
    if (rc) *rc = ESMC_RC_NOT_IMPL;

    // Get pointer
    ip= (int *)(buffer + *offset);

    // Get values
    int sdim=*ip++;
    localsize++;
    int pdim=*ip++;
    localsize++;
    int orig_sdim=*ip++;
    localsize++;
    ESMC_CoordSys_Flag coordsys=static_cast<ESMC_CoordSys_Flag> (*ip++);
    localsize++;

    // Adjust offset
    *offset += localsize*sizeof(int);

    MBMesh_create(mbmpp, &pdim, &sdim, &coordsys, &localrc);
    if (ESMC_LogDefault.MsgFoundError(localrc,ESMCI_ERR_PASSTHRU,ESMC_CONTEXT,NULL))
      return;

// printf("%d# MBMesh_deserialize - 1\n", Par::Rank());

  } catch(std::exception &x) {
    // catch Mesh exception return code
    if (x.what()) {
      ESMC_LogDefault.MsgFoundError(ESMC_RC_INTNRL_BAD,
                                            x.what(), ESMC_CONTEXT, rc);
    } else {
      ESMC_LogDefault.MsgFoundError(ESMC_RC_INTNRL_BAD,
                                            "UNKNOWN", ESMC_CONTEXT, rc);
    }

    return;
  }catch(int localrc){
    // catch standard ESMF return code
    ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU, ESMC_CONTEXT, rc);
    return;
  } catch(...){
    ESMC_LogDefault.MsgFoundError(ESMC_RC_INTNRL_BAD,
                           "- Caught unknown exception", ESMC_CONTEXT, rc);
    return;
  }

// printf("%d# MBMesh_deserialize - 2\n", Par::Rank());

  if (rc!=NULL) *rc=ESMF_SUCCESS;
}


/// REDIST ///

void MBMesh_createredistelems(void **src_meshpp, int *num_elem_gids, int *elem_gids,
                              void **output_meshpp, int *rc) {
#undef  ESMC_METHOD
#define ESMC_METHOD "MBMesh_createredistelems()"

  try {
    int localrc;

    // Dereference
    MBMesh *mesh=reinterpret_cast<MBMesh*> (*src_meshpp);
    MBMesh *out_mesh=reinterpret_cast<MBMesh*> (*output_meshpp);

#if 1
    if (mesh->is_split) {
      // If split mesh expand ids
      int num_elem_gids_ws;
      int *elem_gids_ws=NULL;
      std::map<int,int> split_to_orig_id;

      mbmesh_expand_split_elem_ids(mesh, *num_elem_gids, elem_gids, &num_elem_gids_ws, &elem_gids_ws, split_to_orig_id);

      mbmesh_redist_elem(mesh, &num_elem_gids_ws, elem_gids_ws, &out_mesh);

      out_mesh->is_split=mesh->is_split;
      out_mesh->max_non_split_id=mesh->max_non_split_id;
      out_mesh->split_to_orig_id=split_to_orig_id;

      // calculate split_id_to_frac map from other info
      mbmesh_calc_split_id_to_frac(out_mesh);

      // free split gids
      if (elem_gids_ws !=NULL) delete [] elem_gids_ws;
    } else {
      mbmesh_redist_elem(mesh, num_elem_gids, elem_gids, &out_mesh);
      out_mesh->is_split=mesh->is_split;
    }
#else
    mbmesh_redist_elem(mesh, num_elem_gids, elem_gids, &out_mesh);

    // split element handling
    out_mesh->is_split=mesh->is_split;

    if (out_mesh->is_split) {
      mbmesh_set_split_orig_id_map(mesh, out_mesh);
      out_mesh->max_non_split_id=mesh->max_non_split_id;
      // RLO: not sure we need this if above is used
      // out_mesh->split_to_orig_id=mesh->split_to_orig_id;
    }
#endif

    // return the mbmesh as a void*
    *output_meshpp=reinterpret_cast<void*> (out_mesh);

  } catch(std::exception &x) {
    // catch Mesh exception return code
    if (x.what()) {
      ESMC_LogDefault.MsgFoundError(ESMC_RC_INTNRL_BAD,
                                            x.what(), ESMC_CONTEXT, rc);
    } else {
      ESMC_LogDefault.MsgFoundError(ESMC_RC_INTNRL_BAD,
                                            "UNKNOWN", ESMC_CONTEXT, rc);
    }
  
    return;
  } catch(int localrc){
    // catch standard ESMF return code
    ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU, ESMC_CONTEXT, rc);
    return;
  } catch(...){
    ESMC_LogDefault.MsgFoundError(ESMC_RC_INTNRL_BAD,
                           "- Caught unknown exception", ESMC_CONTEXT, rc);
    return;
  }

  if (rc!=NULL) *rc=ESMF_SUCCESS;

}

void MBMesh_createredistnodes(void **src_meshpp, int *num_node_gids, int *node_gids,
                              void **output_meshpp, int *rc) {
#undef  ESMC_METHOD
#define ESMC_METHOD "MBMesh_createredistnodes()"

  try {
    // Dereference
    MBMesh *mesh=reinterpret_cast<MBMesh*> (*src_meshpp);
    MBMesh *out_mesh=reinterpret_cast<MBMesh*> (*output_meshpp);

    mbmesh_redist_node(mesh, num_node_gids, node_gids, &out_mesh);

    ESMCI_MESHREDIST_TRACE_ENTER("MBMesh split id postprocessing");
    // split element handling
    out_mesh->is_split=mesh->is_split;

    if (out_mesh->is_split) {
      mbmesh_set_split_orig_id_map(mesh, out_mesh);
      out_mesh->max_non_split_id=mesh->max_non_split_id;
      // RLO: not sure we need this if above is used
      // out_mesh->split_to_orig_id=mesh->split_to_orig_id;
    }
    ESMCI_MESHREDIST_TRACE_EXIT("MBMesh split id postprocessing");

  // convert the out_mesh back to a void*
  *output_meshpp = reinterpret_cast<void *> (out_mesh);

  } catch(std::exception &x) {
    // catch Mesh exception return code
    if (x.what()) {
      ESMC_LogDefault.MsgFoundError(ESMC_RC_INTNRL_BAD,
                                            x.what(), ESMC_CONTEXT, rc);
    } else {
      ESMC_LogDefault.MsgFoundError(ESMC_RC_INTNRL_BAD,
                                            "UNKNOWN", ESMC_CONTEXT, rc);
    }

    return;
  }catch(int localrc){
    // catch standard ESMF return code
    ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU, ESMC_CONTEXT, rc);
    return;
  } catch(...){
    ESMC_LogDefault.MsgFoundError(ESMC_RC_INTNRL_BAD,
                           "- Caught unknown exception", ESMC_CONTEXT, rc);
    return;
  }

  if (rc!=NULL) *rc=ESMF_SUCCESS;
}

void MBMesh_createredist(void **src_meshpp, int *num_node_gids, int *node_gids,
                         int *num_elem_gids, int *elem_gids,  
                         void **output_meshpp, int *rc) {
#undef  ESMC_METHOD
#define ESMC_METHOD "MBMesh_createredist()"

  try {
    int localrc;

    // Dereference
    MBMesh *mesh=reinterpret_cast<MBMesh*> (*src_meshpp);
    MBMesh *out_mesh=reinterpret_cast<MBMesh*> (*output_meshpp);

#if 1
    if (mesh->is_split) {
      // If split mesh expand ids
      int num_elem_gids_ws;
      int *elem_gids_ws=NULL;
      std::map<int,int> split_to_orig_id;

      mbmesh_expand_split_elem_ids(mesh, *num_elem_gids, elem_gids, &num_elem_gids_ws, &elem_gids_ws, split_to_orig_id);

      mbmesh_redist(mesh, num_node_gids, node_gids, &num_elem_gids_ws, elem_gids_ws, &out_mesh);
 
      out_mesh->is_split=mesh->is_split;
      out_mesh->max_non_split_id=mesh->max_non_split_id;
      out_mesh->split_to_orig_id=split_to_orig_id;

      // calculate split_id_to_frac map from other info
      mbmesh_calc_split_id_to_frac(out_mesh);

      // Free split gids
      if (elem_gids_ws !=NULL) delete [] elem_gids_ws;
    } else {
      mbmesh_redist(mesh, num_node_gids, node_gids, num_elem_gids, elem_gids, &out_mesh);
      out_mesh->is_split=mesh->is_split;
    }
#else
    mbmesh_redist(mesh, num_node_gids, node_gids, num_elem_gids, elem_gids, &out_mesh);

    // split element handling
    out_mesh->is_split=mesh->is_split;

    if (out_mesh->is_split) {
      mbmesh_set_split_orig_id_map(mesh, out_mesh);
      out_mesh->max_non_split_id=mesh->max_non_split_id;
      // RLO: not sure we need this if above is used
      // out_mesh->split_to_orig_id=mesh->split_to_orig_id;
    }
#endif

    // return the mbmesh as a void*
    *output_meshpp=reinterpret_cast<void*> (out_mesh);


  } catch(std::exception &x) {
    // catch Mesh exception return code
    if (x.what()) {
      ESMC_LogDefault.MsgFoundError(ESMC_RC_INTNRL_BAD,
                                            x.what(), ESMC_CONTEXT, rc);
    } else {
      ESMC_LogDefault.MsgFoundError(ESMC_RC_INTNRL_BAD,
                                            "UNKNOWN", ESMC_CONTEXT, rc);
    }

    return;
  }catch(int localrc){
    // catch standard ESMF return code
    ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU, ESMC_CONTEXT, rc);
    return;
  } catch(...){
    ESMC_LogDefault.MsgFoundError(ESMC_RC_INTNRL_BAD,
                           "- Caught unknown exception", ESMC_CONTEXT, rc);
    return;
  }

  if (rc!=NULL) *rc=ESMF_SUCCESS;

}


// This method verifies that nodes in node_gids array are the same as the local nodes in meshpp, otherwise
// it returns an error (used to test MeshRedist()).
// To do this check make sure the number of nodes in both cases are the same and that every
// entry in node_gids is contained in meshpp
void MBMesh_checknodelist(void **meshpp, int *_num_node_gids, int *node_gids,
                                             int *rc) {
#undef  ESMC_METHOD
#define ESMC_METHOD "MBMesh_checknodelist()"

  try {

    int localrc, merr;
    VM *vm = VM::getCurrent(&localrc);
    int petCount = vm->getPetCount();
    int localPet = vm->getLocalPet();
    if (ESMC_LogDefault.MsgFoundError(localrc,ESMCI_ERR_PASSTHRU,ESMC_CONTEXT,NULL))
      throw localrc;

    // Dereference
    MBMesh *mesh=reinterpret_cast<MBMesh*> (*meshpp);

    // For convenience deref number
    int num_node_gids=*_num_node_gids;

    // Loop through counting local nodes
    Range nodes;
    merr=mesh->mesh->get_entities_by_dimension(0,0,nodes);
    if (merr != MB_SUCCESS) {
      if(ESMC_LogDefault.MsgFoundError(ESMC_RC_MOAB_ERROR,
        moab::ErrorCodeStr[merr], ESMC_CONTEXT,&localrc)) throw localrc;
    }

    // list of the Mesh node gids
    std::vector<UInt> local_gids, local_owners;
    local_gids.reserve(nodes.size());
    local_owners.reserve(nodes.size());

    int num_local_nodes=0;
    Range::const_iterator si = nodes.begin(), se = nodes.end();
    for (; si != se; ++si) {
      const EntityHandle node = *si;

      int node_owner;
      merr=mesh->mesh->tag_get_data(mesh->owner_tag, &node, 1, &node_owner);

      // only consider local nodes
      if (node_owner == localPet) { 
        ++num_local_nodes;

        int gid;
        MBMesh_get_gid(mesh, node, &gid);
        local_gids.push_back(gid);

        local_owners.push_back(node_owner);
#undef print_nodeowners
#ifdef print_nodeowners
        printf("%d# checknodes - node %d owner %d\n", localPet, gid, elem_owner);
#endif
      }
    }

    // See if number of local nodes is the same
    if (num_node_gids != num_local_nodes) {
      Throw() << "Number of local nodes in mesh ("<<num_local_nodes<<
                 ") different that number in list ("<<num_node_gids<<")";
    }


    // Loop making sure nodes are all here
    for (int i=0; i<num_node_gids; i++) {
      std::vector<UInt>::const_iterator ni = std::find(local_gids.begin(), local_gids.end(), node_gids[i]);

      if (ni == local_gids.end()) {
        Throw() << "Node "<<node_gids[i]<<" not found in Mesh.";
      }

      if (local_owners[ni-local_gids.begin()] != localPet) {
        Throw() << "Node "<<node_gids[i]<<" in Mesh, but not local." << local_owners[ni-local_gids.begin()] << "  " << localPet;
      }
    }

  } catch(std::exception &x) {
    // catch Mesh exception return code
    if (x.what()) {
      ESMC_LogDefault.MsgFoundError(ESMC_RC_INTNRL_BAD,
                                            x.what(), ESMC_CONTEXT, rc);
    } else {
      ESMC_LogDefault.MsgFoundError(ESMC_RC_INTNRL_BAD,
                                            "UNKNOWN", ESMC_CONTEXT, rc);
    }

    return;
  }catch(int localrc){
    // catch standard ESMF return code
    ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU, ESMC_CONTEXT, rc);
    return;
  } catch(...){
    ESMC_LogDefault.MsgFoundError(ESMC_RC_INTNRL_BAD,
                           "- Caught unknown exception", ESMC_CONTEXT, rc);
    return;
  }


  if (rc!=NULL) *rc=ESMF_SUCCESS;
}


// This method verifies that elems in elem_gids array are the same as the local elems in meshpp, otherwise
// it returns an error (used to test MeshRedist()).
// To do this check make sure the number of elems in both cases are the same and that every
// entry in elem_gids is contained in meshpp
void MBMesh_checkelemlist(void **meshpp, int *_num_elem_gids, int *elem_gids,
                                             int *rc) {
#undef  ESMC_METHOD
#define ESMC_METHOD "MBMesh_checkelemlist()"

  try {

    // Initialize the parallel environment for mesh (if not already done)
    int localrc, merr;
    VM *vm = VM::getCurrent(&localrc);
    int petCount = vm->getPetCount();
    int localPet = vm->getLocalPet();
    if (ESMC_LogDefault.MsgFoundError(localrc,ESMCI_ERR_PASSTHRU,ESMC_CONTEXT,NULL))
      throw localrc;

    // Dereference
    MBMesh *mesh=reinterpret_cast<MBMesh*> (*meshpp);

    // For convenience deref number
    int num_elem_gids=*_num_elem_gids;


    // Loop through counting local elems
    Range elems;
    merr=mesh->mesh->get_entities_by_dimension(0,mesh->pdim,elems);
    if (merr != MB_SUCCESS) {
      if(ESMC_LogDefault.MsgFoundError(ESMC_RC_MOAB_ERROR,
        moab::ErrorCodeStr[merr], ESMC_CONTEXT,&localrc)) throw localrc;
    }

    // list of the Mesh elem gids
    std::vector<UInt> local_gids, local_owners;
    local_gids.reserve(elems.size());
    local_owners.reserve(elems.size());

    int num_local_elems=0;
    Range::const_iterator si = elems.begin(), se = elems.end();
    for (; si != se; ++si) {
      const EntityHandle elem = *si;

      // Get element id
      int elem_id;
      MBMesh_get_gid(mesh, elem, &elem_id);

      // Don't do split elements
     if (mesh->is_split && (elem_id > mesh->max_non_split_id)) continue;

      int elem_owner;
      merr=mesh->mesh->tag_get_data(mesh->owner_tag, &elem, 1, &elem_owner);
      if (merr != MB_SUCCESS) {
        if(ESMC_LogDefault.MsgFoundError(ESMC_RC_MOAB_ERROR,
          moab::ErrorCodeStr[merr], ESMC_CONTEXT,&localrc)) throw localrc;
      }

      if (elem_owner == localPet) {
        num_local_elems++;

        int gid;
        MBMesh_get_gid(mesh, elem, &gid);
        local_gids.push_back(gid);

        local_owners.push_back(elem_owner);
#undef print_elemowners
#ifdef print_elemowners
        printf("%d# checkelems - elem %d owner %d\n", localPet, gid, elem_owner);
#endif
      }
    }

    // See if number of local elems is the same
    if (num_elem_gids != num_local_elems) {
      Throw() << "Number of local elems in mesh ("<<num_local_elems<<
                 ") different that number in list ("<<num_elem_gids<<")";
    }

    // Loop making sure elems are all here
    for (int i=0; i<num_elem_gids; i++) {
      std::vector<UInt>::const_iterator ni = std::find(local_gids.begin(), local_gids.end(), elem_gids[i]);

      if (ni == local_gids.end()) {
        Throw() << "Node "<<elem_gids[i]<<" not found in Mesh.";
      }

      if (local_owners[ni-local_gids.begin()] != localPet) {
        Throw() << "Elem "<<elem_gids[i]<<" in Mesh, but not local." << local_owners[ni-local_gids.begin()] << "  " << localPet;
      }
    }


#undef debug_printentities
#ifdef debug_printentities
    {
    Range nodes;
    merr=mesh->mesh->get_entities_by_dimension(0,0,nodes);
    if (merr != MB_SUCCESS) {
      if(ESMC_LogDefault.MsgFoundError(ESMC_RC_MOAB_ERROR,
        moab::ErrorCodeStr[merr], ESMC_CONTEXT,&localrc)) throw localrc;
    }

    Range::const_iterator ni = nodes.begin(), ne = nodes.end();
    for (; ni != ne; ++ni) {
      const EntityHandle ent = *ni;
      int gid;
      MBMesh_get_gid(mesh, ent, &gid);
      int owner;
      merr=mesh->mesh->tag_get_data(mesh->owner_tag, &ent, 1, &owner);
      if (merr != MB_SUCCESS) {
        if(ESMC_LogDefault.MsgFoundError(ESMC_RC_MOAB_ERROR,
          moab::ErrorCodeStr[merr], ESMC_CONTEXT,&localrc)) throw localrc;
      }

      printf("%d# checkelems - node %d owner %d\n", localPet, gid, owner);
    }

    // Range edges;
    // merr=mesh->mesh->get_entities_by_dimension(0,1,edges);
    // if (merr != MB_SUCCESS) {
    //   if(ESMC_LogDefault.MsgFoundError(ESMC_RC_MOAB_ERROR,
    //     moab::ErrorCodeStr[merr], ESMC_CONTEXT,&localrc)) throw localrc;
    // }
    // 
    // Range::const_iterator ei = edges.begin(), ee = edges.end();
    // for (; ei != ee; ++ei) {
    //   const EntityHandle ent = *ei;
    //   int gid;
    //   MBMesh_get_gid(mesh, ent, &gid);
    //   int owner;
    //   merr=mesh->mesh->tag_get_data(mesh->owner_tag, &ent, 1, &owner);
    //   if (merr != MB_SUCCESS) {
    //     if(ESMC_LogDefault.MsgFoundError(ESMC_RC_MOAB_ERROR,
    //       moab::ErrorCodeStr[merr], ESMC_CONTEXT,&localrc)) throw localrc;
    //   }
    // 
    //   printf("%d# checkelems - edge %d owner %d\n", localPet, gid, owner);
    // }

    Range elems;
    merr=mesh->mesh->get_entities_by_dimension(0,mesh->pdim,elems);
    if (merr != MB_SUCCESS) {
      if(ESMC_LogDefault.MsgFoundError(ESMC_RC_MOAB_ERROR,
        moab::ErrorCodeStr[merr], ESMC_CONTEXT,&localrc)) throw localrc;
    }

    Range::const_iterator si = elems.begin(), se = elems.end();
    for (; si != se; ++si) {
      const EntityHandle ent = *si;
      int gid;
      MBMesh_get_gid(mesh, ent, &gid);
      int owner;
      merr=mesh->mesh->tag_get_data(mesh->owner_tag, &ent, 1, &owner);
      if (merr != MB_SUCCESS) {
        if(ESMC_LogDefault.MsgFoundError(ESMC_RC_MOAB_ERROR,
          moab::ErrorCodeStr[merr], ESMC_CONTEXT,&localrc)) throw localrc;
      }

      printf("%d# checkelems - elem %d owner %d\n", localPet, gid, owner);
    }
    }
#endif

#undef debug_printmoabsharedinfo
#ifdef debug_printmoabsharedinfo
  MPI_Comm mpi_comm = vm->getMpi_c();


  ParallelComm *pcomm = ParallelComm::get_pcomm(mesh->mesh, 0);

  int nprocs = pcomm->size();
  int rank = pcomm->rank();

  Range shared_ents;
  // Get entities shared with all other processors
  merr = pcomm->get_shared_entities(-1, shared_ents);
  MBMESH_CHECK_ERR(merr, localrc);
  
  // Filter shared entities with not not_owned, which means owned
  Range owned_entities;
  merr = pcomm->filter_pstatus(shared_ents, PSTATUS_NOT_OWNED, PSTATUS_NOT, -1, &owned_entities);
  MBMESH_CHECK_ERR(merr, localrc);
    
  unsigned int nums[4] = {0}; // to store the owned entities per dimension
  for (int i = 0; i < 4; i++)
    // nums[i] = (nt)shared_ents.num_of_dimension(i);
    nums[i] = (int)owned_entities.num_of_dimension(i);
    
  std::vector<int> rbuf(nprocs*4, 0);
  MPI_Gather(nums, 4, MPI_INT, &rbuf[0], 4, MPI_INT, 0, mpi_comm);
  // Print the stats gathered:
  if (0 == rank) {
    for (int i = 0; i < nprocs; i++)
      std::cout << " Shared, owned entities on proc " << i << ": " << rbuf[4*i] << " verts, " <<
          rbuf[4*i + 1] << " edges, " << rbuf[4*i + 2] << " faces, " << rbuf[4*i + 3] << " elements" << std::endl;
  }
#endif

#define DEBUG_WRITE_MESH
#ifdef DEBUG_WRITE_MESH
  {void *mbptr = (void *) mesh;
  int rc;
  int len = 12; char fname[len];
  sprintf(fname, "meshredist_%d", localPet);
  MBMesh_write(&mbptr, fname, &rc, len);}
#endif


  } catch(std::exception &x) {
    // catch Mesh exception return code
    if (x.what()) {
      ESMC_LogDefault.MsgFoundError(ESMC_RC_INTNRL_BAD,
                                            x.what(), ESMC_CONTEXT, rc);
    } else {
      ESMC_LogDefault.MsgFoundError(ESMC_RC_INTNRL_BAD,
                                            "UNKNOWN", ESMC_CONTEXT, rc);
    }

    return;
  }catch(int localrc){
    // catch standard ESMF return code
    ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU, ESMC_CONTEXT, rc);
    return;
  } catch(...){
    ESMC_LogDefault.MsgFoundError(ESMC_RC_INTNRL_BAD,
                           "- Caught unknown exception", ESMC_CONTEXT, rc);
    return;
  }


  if (rc!=NULL) *rc=ESMF_SUCCESS;
}

#if 0
void MBMesh_FitOnVM(Mesh **meshpp,
                       VM **new_vm,
                       int *rc)
{
#undef  ESMC_METHOD
#define ESMC_METHOD "ESMCI_MeshFitOnVM()"
  int localrc;

   try {

     // Initialize the parallel environment for mesh (if not already done)
     {
       ESMCI::Par::Init("MESHLOG", false /* use log */,VM::getCurrent(&localrc)->getMpi_c());
       if (ESMC_LogDefault.MsgFoundError(localrc,ESMCI_ERR_PASSTHRU,ESMC_CONTEXT,NULL))
         throw localrc;  // bail out with exception
     }

     // Get Pointer to Mesh
     ThrowRequire(meshpp);
     Mesh *mesh = *meshpp;

     // Get current VM
     VM *curr_vm=VM::getCurrent(&localrc);
     if (ESMC_LogDefault.MsgFoundError(localrc,ESMCI_ERR_PASSTHRU,ESMC_CONTEXT,NULL))
       throw localrc;  // bail out with exception

     // Get current VM size
     int curr_vm_size=curr_vm->getPetCount();

     // Get current VM rank
     int curr_vm_rank=curr_vm->getLocalPet();

     // Describe mapping of current PET
     int new_vm_rank=-1; // if there is no pet, set to -1
     if ((ESMC_NOT_PRESENT_FILTER(new_vm) != ESMC_NULL_POINTER) && *new_vm) {
       new_vm_rank=(*new_vm)->getLocalPet();
     }

     // Allocate array
     int *rank_map=new int[curr_vm_size];

     // Create array mapping from current vm to input vm
     localrc=curr_vm->allgather(&new_vm_rank,rank_map,sizeof(int));
     if (ESMC_LogDefault.MsgFoundError(localrc,ESMCI_ERR_PASSTHRU,ESMC_CONTEXT,NULL))
       throw localrc;  // bail out with exception

#if 0
     // debug output
     for (int p=0; p<curr_vm_size; p++) {
       printf("%d# %d to %d\n",curr_vm_rank,p,rank_map[p]);
     }
#endif

     // Change proc numbers in mesh
     mesh->map_proc_numbers(curr_vm_size, rank_map);

    // Free map
    delete [] rank_map;

    return;
  }catch(int localrc){
    // catch standard ESMF return code
    ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU, ESMC_CONTEXT,rc);
    return;
  } catch(...){
    ESMC_LogDefault.MsgFoundError(ESMC_RC_INTNRL_BAD,
      "- Caught unknown exception", ESMC_CONTEXT, rc);
    return;
  }

  // Set return code
  if (rc!=NULL) *rc = ESMF_SUCCESS;


} // ESMCI_MeshFitOnVM

 // Change the proc numbers in a mesh to correspond to a different set. This isn't to 
 // merge procs into one another, but to map them to different number. E.g. if they 
 // are being switched to a different VM or MPI_COMM.
 void Mesh::map_proc_numbers(int num_procs, int *proc_map) {

     // Loop through nodes changing owners to owners in new VM
     MeshDB::iterator ni = this->node_begin_all(), ne = this->node_end_all();
     for (; ni != ne; ++ni) {
       MeshObj &node=*ni;

       // Get original owner
       UInt orig_owner=node.get_owner();

       // Error check owner
       if ((orig_owner < 0) || (orig_owner > num_procs-1)) {
         Throw()<<" mesh node owner rank outside current vm";
       }

       // map to new owner rank in new vm
       int new_owner=proc_map[orig_owner];

       // Make sure that the new one is ok
       if (new_owner < 0) {
         Throw()<<" mesh node owner outside of new vm";
       }

       // Set new owner
       node.set_owner((UInt)new_owner);
     }


     // Loop through elems changing owners to owners in new VM
     MeshDB::iterator ei = this->elem_begin_all(), ee = this->elem_end_all();
     for (; ei != ee; ++ei) {
       MeshObj &elem=*ei;

       // Get original owner
       UInt orig_owner=elem.get_owner();

       // Error check owner
       if ((orig_owner < 0) || (orig_owner > num_procs-1)) {
         Throw()<<" mesh element owner rank outside current vm";
       }

       // map to new owner rank in new vm
       int new_owner=proc_map[orig_owner];

       // Make sure that the new one is ok
       if (new_owner < 0) {
         Throw()<<" mesh element owner outside of new vm";
       }

       // Set new owner
       elem.set_owner((UInt)new_owner);
     }

     // Change CommReg
     CommReg::map_proc_numbers(num_procs, proc_map);

     // Remove ghosting, because it would be wrong now that procs have changed.
     RemoveGhost();
 }

#endif

#endif // ESMF_MOAB
